package boundedResponseTests
public
  with boundedResponse;
  renames boundedResponse::all;
  
  with AGREE_PLTL;
  renames AGREE_PLTL::all;
  
  process should_doNothing_when_noInput
    features
      Response: in event port;
      Request: in event port;
      Alert: out event port;
    annex agree {**
      assume "No Response" :
      	event(Response) = false;
      assume "No Request" :
      	event(Request) = false;
      	
      guarantee "Not Alert" :
      	not event(Alert);
    **};
  end should_doNothing_when_noInput;
  
  process Implementation should_doNothing_when_noInput.test
  	subcomponents
  	  Monitor: thread boundedResponse.Impl;
  	connections
  	  c00: port Response -> Monitor.response;
  	  c01: port Request -> Monitor.request;
  	  c02: port Monitor.alert -> Alert;
  end should_doNothing_when_noInput.test;
  
  process should_alert_when_responseWithoutRequest
    features
      Response: in event port;
      Request: in event port;
      Alert: out event port;
    annex agree {**
      assume "Response" :
      	event(Response) = true ->
      	event(Response) = false;
      assume "Not Request" :
      	event(Request) = false;
      	
      guarantee "Alert" :
      	event(Alert);
    **};
  end should_alert_when_responseWithoutRequest;
  
  process Implementation should_alert_when_responseWithoutRequest.test
  	subcomponents
  	  Monitor: thread boundedResponse.Impl;
  	connections
  	  c00: port Response -> Monitor.response;
  	  c01: port Request -> Monitor.request;
  	  c02: port Monitor.alert -> Alert;
  end should_alert_when_responseWithoutRequest.test;
  
  process should_notAlert_when_responseAndRequest
    features
      Response: in event port;
      Request: in event port;
      Alert: out event port;
    annex agree {**
      assume "One Response" :
      	event(Response) = true ->
      	event(Response) = false;
      assume "One Request" :
      	event(Request) = true ->
      	event(Request) = false;
      	
      guarantee "Not Alert" :
      	not event(Alert);
    **};
  end should_notAlert_when_responseAndRequest;
  
  process Implementation should_notAlert_when_responseAndRequest.test
  	subcomponents
  	  Monitor: thread boundedResponse.Impl;
  	connections
  	  c00: port Response -> Monitor.response;
  	  c01: port Request -> Monitor.request;
  	  c02: port Monitor.alert -> Alert;
  end should_notAlert_when_responseAndRequest.test;
  
   process should_notAlert_when_responseOneStepAfterRequest
    features
      Response: in event port;
      Request: in event port;
      Alert: out event port;
    annex agree {**
      eq index : int = prev(index + 1, 0);
      
      assume "One Response one step after Request" :
      	    ((index = 0) => not event(Response))
      	and ((index = 1) => event(Response))
      	and ((index >= 2) => not event(Response));
      assume "One Request" :
      	(event(Request) = true) ->
      	(event(Request) = false);
      
      guarantee "Not Alert" :
      	not event(Alert);
    **};
  end should_notAlert_when_responseOneStepAfterRequest;
  
  process Implementation should_notAlert_when_responseOneStepAfterRequest.test
  	subcomponents
  	  Monitor: thread boundedResponse.Impl;
  	connections
  	  c00: port Response -> Monitor.response;
  	  c01: port Request -> Monitor.request;
  	  c02: port Monitor.alert -> Alert;
  end should_notAlert_when_responseOneStepAfterRequest.test;
  
  process should_alert_when_noResponseOneStepAfterRequest
    features
      Response: in event port;
      Request: in event port;
      Alert: out event port;
    annex agree {**
      assume "One response one step after Request" :
      	(event(Response) = false);
      assume "One Request" :
      	(event(Request) = true) ->
      	(event(Request) = false);
      
      guarantee "Alert one step after Request" :
      	not event(Alert) -> event(Alert);
    **};
  end should_alert_when_noResponseOneStepAfterRequest;
  
  process Implementation should_alert_when_noResponseOneStepAfterRequest.test
  	subcomponents
  	  Monitor: thread boundedResponse.Impl;
  	connections
  	  c00: port Response -> Monitor.response;
  	  c01: port Request -> Monitor.request;
  	  c02: port Monitor.alert -> Alert;
  end should_alert_when_noResponseOneStepAfterRequest.test;

  process should_passAgree_when_allBehaviorsAssumedAndGuaranteed
    features
      Response: in event port;
      Request: in event port;
      Alert: out event port;
    annex agree {**
      eq rsp : bool = event(Response);
      eq req : bool = event(Request);
      
      assume "One automation request in flight at a time" :
        true -> (req => pre(Historically(not req) or Since(not req, rsp))); 
        
      eq isAlert : bool = (rsp and not req) ->
        (   (pre(req and not rsp) and not rsp)
         or (rsp and (not req) and pre(not req or (req and rsp)))
         or pre(isAlert));
         
      guarantee "Alert late response, orphaned response, or pre-state alert" :
      	event(Alert) = isAlert;
    **};
  end should_passAgree_when_allBehaviorsAssumedAndGuaranteed;
  
  process Implementation should_passAgree_when_allBehaviorsAssumedAndGuaranteed.test
  	subcomponents
  	  Monitor: thread boundedResponse.Impl;
  	connections
  	  c00: port Response -> Monitor.response;
  	  c01: port Request -> Monitor.request;
  	  c02: port Monitor.alert -> Alert;
  end should_passAgree_when_allBehaviorsAssumedAndGuaranteed.test;
end boundedResponseTests;