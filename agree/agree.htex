\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{AGREE Semantics and Correct Code Generation}
\author{Konrad Slind}{Trusted Systems Group, Collins Aerospace, USA}{konrad.slind@collins.com}{}{}
\authorrunning{K. Slind}

\usepackage{holtexbasic}
\usepackage{alltt}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsbsy}

\usepackage{tikz}
\usetikzlibrary{shapes}
\usetikzlibrary{shapes.symbols}

\newcommand{\ie}{\textit{i.e.}}
\newcommand{\eg}{\textit{e.g.}}
\newcommand{\etal}{\textit{et al.}}
\newcommand{\etc}{\textit{etc.}}
\newcommand{\adhoc}{\textit{ad hoc}}
\newcommand{\konst}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\imp}{\Rightarrow}
\newcommand{\lval}{\ensuremath{\mathit{lval}}}
\newcommand{\set}[1]{\ensuremath{\{ {#1} \}}}
\newcommand{\kstar}[1]{\ensuremath{{#1}^{*}}}
\newcommand{\Lang}[1]{\ensuremath{{\mathcal L}({#1})}}
\newcommand{\sem}[1]{\ensuremath{[\![ #1 ]\!]}}
\newcommand{\itelse}[3]{\mbox{$\mathtt{if}\ {#1}\ \mathtt{then}\ {#2}\ \mathtt{else}\ {#3}$}}
\newcommand{\aadl}{\textsc{AADL}}
\newcommand{\agree}{\textsc{AGREE}}
\newcommand{\splat}{\textsc{SPLAT}}
\newcommand{\clustre}{\emph{Clustre}}

\begin{document}

\maketitle


\begin{abstract}

We define the formal semantics of the {\agree} contract specification
language in terms of streams and discuss how the semantics is
leveraged to formally prove the correctness of code generation from
{\agree} specifications.

\end{abstract}

\section{Introduction}\label{sec:intro}

{\agree}\cite{agree} is a language for specifying the behaviour of
systems expressed in the AADL system modelling language
\cite{aadl}. In {\agree}, the behaviour of an AADL component is
expressed via \emph{Assume-Guarantee} contracts on the external ports
of the component. These contracts are essentially predicates over the
streams of values on the ports. There is an {\agree} model-checker
which follows the hierarchical structure of a system in order to
verify upper-level contracts in terms of lower-level contracts. All of
this ultimately focuses our attention on the behaviour of leaf-level
components in an architecture, and the correctness issue resolves to
the question: \emph{do the implementations of the leaf components meet
their contracts?}  This proof obligation is approachable in various
ways: for example, it can be dealt with by inspection, by unit testing,
or by formal proof. We take a formal synthesis approach: given a
sufficiently detailed contract, we generate code from it and formally
prove that the code indeed meets the contract.

The synthesis step requires that the component have a \emph{computable}
contract. In this document, we go into detail about what this exactly
means. In particular, we give a formal syntax and semantics for a
stream-valued language called \emph{Core Lustre}---abbreviated
{\clustre}---and argue that it captures the essence of
      {\agree}. Then we show how {\clustre} programs are
      translated to a sequential language with no streams, and prove
      the correctness of the translation. At that point we can inject
      the (transformed) program into the verified CakeML compiler
      infrastructure and obtain a binary that behaves as the original
      contract specifies.

\section{{\agree} syntax}\label{sec:syntax}

An {\agree} leaf-level \emph{component} is the object of study. A
component has a collection of input ports and output ports, local
state variable assignments, output port assignments, and, for
specification purposes, assumptions and guarantees. At runtime, a
component is perpetually (re-)invoked; in an invocation it reads from
the input ports, updates its state variables, then computes values to be
written to its output ports. However, a {\clustre} component is
abstract and part of our discussion shows how an abstract component is
refined to the target behaviour.

A component is represented by the following record type:

\begin{HOLmath}
\HOLthm[m;,>>3]{agree.datatype_component}
\end{HOLmath}

Assumptions are boolean expressions over the input ports, while
guarantees are boolean expressions that can refer to input port
values, the values of variables, and the values on output ports.  We
will use the following notation to describe a component:

\[
\begin{array}{ll}
{A_1 \land \cdots \land A_i}       & \text{-- assumptions} \\
  v_1 = e_1;\  \cdots ;\ v_j = e_j    & \text{-- variable definitions} \\
  o_1 = e_{j+1};\ \cdots ;\ o_k = e_{j+k} & \text{-- output definitions} \\
{G_1 \land \cdots \land G_m}       & \text{-- guarantees} \\
\end{array}
\]

\subsection{Expressions, values, and statements}

{\agree} expressions are conventional arithmetic/boolean expressions,
extended with Lustre-style \verb+fby+ and \verb+pre+ operators to help specify
temporally-influenced behaviours. We also provide a
\emph{Historically} operator (\verb+Hist+).

\begin{HOLmath}
\HOLthm[m;,>>3]{agree.datatype_expr}
\end{HOLmath}

Values of expressions are combined into a joint type of integer
literals and boolean literals. This supports the definition of
environments, which map variable names to value streams.
%
\begin{HOLmath}
\HOLthm[m;,>>3;width=5]{agree.datatype_value}
\\ \\
\HOLthm[m;,def,>>3]{agree.bool_of_def} \\
\HOLthm[m;,def,>>3]{agree.int_of_def}
\end{HOLmath}

Variable definitions are treated as assignment statements. In the
current work there are only integer and boolean assignments. We are
deferring issues about types for now.

\begin{HOLmath}
\HOLthm[m;,>>3]{agree.datatype_stmt}
\end{HOLmath}

\section{{\agree} semantics}\label{sec:semantics}

AGREE components express computations over streams, where a stream is
defined as a function from time (natural numbers) to values. Input
streams are immutable, while the value of an output stream at time $t$
is computed using the values of variables at time $t$ or earlier.
%
\[
\konst{stream} = \konst{nat} \to \konst{value}
\]
A \emph{stream environment} is a finite map from a \emph{name} (input port
name, output port name, or variable name) to a \konst{value} stream.
%
\[
  \konst{strm\_env} = \konst{string} \mapsto (\konst{nat} \to \konst{value})
\]

\begin{definition}[Environment update]

Variable assignment is modelled by updating the named stream in an
environment at a point in time:
%
\begin{HOLmath}
\HOLthm[m;,def,>>3]{agree.updateEnv_def}
\end{HOLmath}

\begin{remark}[Notation]
The expression \HOLtm{env ' name t} means `the value of variable
$\mathit{name}$ in environment $\mathit{env}$ at time $t$'.
\end{remark}

\end{definition}

\subsection{Expression valuation}

Evaluation of an expression is defined with respect to a given
environment $E$ and a time $t$. (Some cases of the definition have
been elided.)
%
\begin{definition}[Expression evaluation]
\begin{HOLmath}
\HOLthm[m;,def,>>3,conj1]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj2,width=75]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj3,width=75]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj8,width=75]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj9,width=95]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj10,width=95]{agree.exprVal_def} \\  \\
\HOLthm[m;,def,>>3,conj11]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj13,width=75]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj14,width=75]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj18,width=75]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj19,width=75]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj21,width=75]{agree.exprVal_def} \\
\end{HOLmath}

\end{definition}

\begin{remark}[Partiality]
The semantics of \konst{PreExpr} requires that it is undefined at time
0. Because HOL does not support true undefinedness, we have used the
\konst{ARB} constant of HOL which is a polymorphic constant denoting a
fixed arbitrary element of its type. \konst{ARB} is useful for specification but it does not
have a computational value. We have considered using some fixed
integer---such as 42---instead, but that will not extend well to a
more complex type regime. Instead, we could make expression evaluation
explicitly partial, by using option types. We have done this in our
actual implementation, but for now we will stick with \konst{ARB}.
\end{remark}


\subsection{Statement and component semantics}

The \emph{effect} of a statement $s = \mathit{exp}$ in an environment $E$ at time
$t$ is an updated environment $E'$, where variable $s$ has its value
at time $t$ set to the value of $\mathit{exp}$.
%
\begin{HOLmath}
\HOLthm[m;,def,>>3,width=95]{agree.stmtFn_def}
\end{HOLmath}
The sequential composition of a list of statements at time $t$ is
defined with a left-to-right fold.
%
\begin{HOLmath}
\HOLthm[m;,def,>>3]{agree.stmtListFn_def}
\end{HOLmath}
The effect of a component is the environment obtained by evaluating
the variable assignments given the input port values. The variable
definitions are evaluated in sequence, and then the output definitions
are evaluated in sequence. Time does not advance as the definitions
are evaluated. Because of syntactic constraints, described later, the
output statements are independent of each other and can be thought of
as being evaluated in parallel.
%
\begin{HOLmath}
\HOLthm[m;,def,>>3,width=90]{agree.strmStep_def}
\end{HOLmath}
%
We now extend the component behaviour through time, and do this by
iterating the effect of the component, starting from a given
environment.
%
\begin{HOLmath}
\HOLthm[m;,def,>>3,width=85]{agree.strmSteps_def}
\end{HOLmath}

Note that the component effect is not given default value at time
0. The first input of the component arrives at time 0, and thus there
is also a computation and output at time 0.

\subsection{Component contracts}

Given value streams at the input ports, and the value streams for
state and output variables, the \emph{contract} of the component can
be expressed. The \emph{assumptions} are assumed to hold for all times up to
the present, and the \emph{guarantees} need to hold at the present time (but
can of course refer to previous values in the variable streams by use
of the temporal operators).

\begin{HOLmath}
\HOLthm[m;,def,>>3,width=75]{agree.assumsVal_def}
\\
\HOLthm[m;,def,>>3]{agree.guarsVal_def}
\end{HOLmath}

Finally, the \emph{correctness} of a component can be defined: under
some wellformedness conditions, a component is correct if its
guarantees hold after any finite number of steps.

\begin{HOLmath}
\HOLthm[m;,def,>>3]{agree.Component_Correct_def}
\end{HOLmath}

Correctness is conditional on the assumptions holding in the given
environment $E$. Thus, should the inputs to a component \emph{not}
satisfy the assumptions, the component is deemed to be correct, no
matter how it behaves.

\subsection{Wellformedness and support}

A component $C$ is required to have the following (statically checkable)
wellformedness conditions.
%
\begin{enumerate}
\item All the declared variables of $C$ are distinct
\item There are no undeclared variables in the body of $C$
\item Output port variables (those declared in $\mathit{C.out\_defs}$)
  do not occur in the right hand side of any definition.
\item If a variable occurs before its defining equation it has to
  occur as an argument to $\konst{pre}$
\item In every $\konst{pre}(e)$ expression, $e$ is a variable
\end{enumerate}

Condition 1 prevents re-declaration of variables. Condition 2 helps
ensure that every expression in the component will have a
value. Condition 3 ensures that output variables are independent of
each other: they only depend on their right hand sides (and can not be
recursive). Moreover, the value of an output does not affect the value
of any other variable.

Conditions 4 and 5 support the implementation of $C$ in an ordinary
sequential manner. Variables must be defined before use, except that
$\konst{pre}(v)$, if it occurs, must occur before the definition of
variable $v$. Programs that look further back than one time step in
their value streams are banned by 4 and 5. We will discuss a program
transformation that treats such programs.

There is also a requirement that an environment \emph{supports} a
component, \ie{} provides streams corresponding to each input port,
state variable, and output variable in the component.
%
\begin{HOLmath}
\HOLthm[m;,def,>>3]{agree.Supports_def}
\end{HOLmath}

As a consequence of these conditions, input port streams are
immutable: program execution will not alter them.
%
\begin{HOLmath}
\HOLthm[m;,>>3]{agree.Inputs_Stable}
\end{HOLmath}

In contrast, the state and output variable streams, initially
unconstrained, are incrementally determined as execution via
\konst{strmSteps} progresses. Once a state- or output-variable stream
element is determined at time $t$, subsequent computation will not
change it.
%
\begin{HOLmath}
\HOLthm[m;,>>3]{agree.strmSteps_timeframe}
\end{HOLmath}


\section{Examples}

We now examine some small examples.

\subsection{Sorted}

In this example, we pretend that only integers are available. The
output goes high, and stays high, as soon as a negative difference
between adjacent inputs is detected.

{\small
\begin{verbatim}
  I = [input]
  A = []
  V = [diff  = 0 -> input - pre input]
       alert = 0 -> if diff < 0 then 1 else pre alert
  O = [output = (alert = 0)]
  G = [output iff Hist (0 <= diff)]
\end{verbatim}
}


\subsection{Divsum}

This example shows the use of assumptions on the input
stream. Provided that input \konst{i2} is always positive and input
\konst{i1} is non-negative, the result is always defined (and
non-negative).

{\small
\begin{verbatim}
  I = [i1,i2]
  A = [0 <= i1, 0 < i2]
  V = [divsum = (i1 / i2) -> pre divsum + (i1/i2)]
  O = [output = divsum]
  G = [0 <= output]
\end{verbatim}
}

\subsection{Fibonacci}

The \emph{Fibonacci} sequence proceeds $1,1,2,3,5,8,13, \ldots$ and is defined recursively by
%
\[
 \konst{fib}(t) = \mathtt{if}\; t\; \leq 1 \; \mathtt{then}\; 1 \; \mathtt{else}\; \konst{fib}(t-1) + \konst{fib}(t-2)
\]
%
An iterative version uses two variables to hold the two earlier values
in the sequence:
%
{\small
\begin{verbatim}
  x = 0 -> pre y;
  y = 1 -> pre x + pre y
  output = y
\end{verbatim}
}
%
\noindent What about a recursive presentation? One approach is as follows:
%
{\small
\begin{verbatim}
  fib = 1 -> pre(1 -> fib + pre fib)
  output = fib
\end{verbatim}
}
%
However, this is somewhat unnatural compared to the mathematical
definition, and it doesn't seem to generalize to a wide variety of
recursions. By realizing that the stream index can be made explicit,
the usual recursion equation can be rendered:
%
{\small
\begin{verbatim}
  N = 0 -> pre N + 1
  fib = if  N <= 1 then 1 else pre fib + pre(pre fib)
\end{verbatim}
}
%
This trick, of making the stream index explicit, can be used to help
define a wide variety of course-of-values recursions.

\subsection{Arithmetic Progression}

An \emph{arithmetic progression} is a sequence of numbers where the
difference between adjacent elements is constant. For example
$2,6,10,14, \ldots$ is an arithmetic progression with a common
difference of four.  The following {\clustre} program incrementally
tests whether its input stream $\mathit{input}$ is an arithmetic
progression.
%
{\small
\begin{verbatim}
  N = 0 -> pre N + 1
  isProg = if N <= 1 then
            true
           else
             isProg and (input - pre input = pre input - pre(pre input))
\end{verbatim}
}
%
The common difference is computed from the first three numbers. An
interesting aspect of this program is that earlier values of the
\konst{input} stream need to be tracked, but \konst{input}, being a
parameter, does not have a defining equation.


\section{Compilation and Code Generation}\label{sec:codegen}

We now discuss transformations that move from stream-based {\clustre}
programs to purely extension functions ready to be mapped to CakeML.

\begin{description}
\item [History squashing] maps a {\clustre} program to an
  equivalent version that looks back at most one step in its history.
\item [Work over serialized data] by invoking decoders on serialized
  input and encoders to serialize output. This prepares the program to
  be put in a computational setting where input and output is through
  byte buffers.
\end{description}

A chain of theorems will relate the result of these transformations
back to the original {\clustre} program. Throughout these
transformation steps the meaning of the component is that it is a
mathematical function of some kind. Our goal is to do as much
formalization and proof in the world of mathematical functions
(shallow embeddings) before eventually moving, in a
property-preserving way, to CakeML abstract syntax and
evaluation. Once our (transformed) {\clustre} has been transported to
the setting of CakeML semantics, we can access imperative features
such as imperative variables and the CakeML Foreign Function Interface
(FFI), which we use in order to get input and emit output.

One simple way to describe the transformations is by examining how
they change the type of environment being used, from stream
environments to value environments to buffer environments. This is
revealed in the progression from a stream-oriented step function to a
value-oriented step function, to a mixed buffer-and-value oriented
step function.

\subsection{Stream oriented step function}

The semantics of {\clustre} treats component execution as a
transformation between an initial stream environment and the stream
environment resulting from $t$ steps of execution:
\[
\konst{strmStep} :
  \konst{strm\_env} \to \konst{component} \to \konst{num} \to \konst{strm\_env}
\]

\subsection{Value oriented step function}

Once all history variables have been squashed down to length at most
one, the program is essentially an imperative program operating over a
state and can be evaluated with respect to an environment that binds
variable names to values (thus the time index is not needed):
\[
\begin{array}{rcl}
\konst{stateStep} & : & \konst{component} \to \\
& &   \underbrace{(\konst{string} \mapsto \konst{value}) * (\konst{string} \mapsto \konst{value})}_{inputs * state}
  \to
    \underbrace{(\konst{string} \mapsto \konst{value}) * (\konst{string} \mapsto \konst{value})}_{state * outputs}
\end{array}
\]
\konst{stateStep} takes the current inputs and state and returns a new state and outputs:
%
\begin{HOLmath}
\HOLthm[m;,def,>>3,width=75]{state.stateStep_def}
\end{HOLmath}

\subsection{Value-and-buffer oriented step function}

At this point, we can add parsers for the inputs and serializers for
outputs. To defer the choice of parsers and serializers, we make them
parameters in the definition of \konst{bufStep}.
\[
\begin{array}{rcl}
\konst{bufStep} & : & (\overbrace{(\konst{value}\to \konst{string}}^{encode}) *
                       \overbrace{(\konst{string}\to \konst{value}}^{decode})) \to
\konst{component} \to \\
& &   \underbrace{(\konst{string} \mapsto \konst{string}) * (\konst{string} \mapsto \konst{value})}_{inputs * state}
  \to
    \underbrace{(\konst{string} \mapsto \konst{value}) * (\konst{string} \mapsto \konst{string})}_{state * outputs}
\end{array}
\]

\konst{bufStep} takes the current inputs and state and returns a new state and outputs:

\begin{HOLmath}
\HOLthm[m;,def,>>3,width=75]{state.bufStep_def}
\end{HOLmath}

\subsection{Example: Arithmetic Progression Recognizer}

The original {\clustre} program recognizing arithmetic progressions
looks both one and two steps back in the input stream:
%
{\small
\begin{verbatim}
  inports = [input]
  N = 0 -> pre N + 1
  ap = if N <= 1 then
         T
       else
        ap and (input - pre input = pre input - pre(pre input))
  output = ap
\end{verbatim}
}
%
Temporal squashing removes all nested $\konst{pre}(-)$ expressions and
introduces two streams to hold earlier values of the \konst{input}
stream: \konst{in2} holds the value of \konst{input} two steps earlier
and \konst{in1} holds the value of \konst{input} from the previous
step.
%
{\small
\begin{verbatim}
    N = 0 -> 1 + pre N
  in2 = 42 -> pre in1
  in1 = 42 -> pre input
   ap = if N <= 1 then
         T
       else
         pre(ap) and (input - in1 = in1 - in2)
\end{verbatim}
}
%
As mentioned earlier, the expression $\konst{pre}(\konst{input})$
occurs, but there is no defining equation for \konst{input}. (This
makes sense since the input at this stage of formalization is simply a
given parameter.) The calculation of \konst{in1} requires
$\konst{pre}(\konst{input})$ while the calculation of \konst{ap} uses
\konst{input}. We therefore add a variable definition $\konst{inVar} =
\konst{input}$ which holds the value of \konst{input} and is thus able
to have $\konst{pre}(-)$ applied to it.
%
{\small
\begin{verbatim}
      N = 0 -> 1 + pre N
    in2 = 42 -> pre in1
    in1 = 42 -> pre inVar
  inVar = input
     ap = if N <= 1 then
            T
          else
            pre(ap) and (input - in1 = in1 - in2)
\end{verbatim}
}
%
The temporal references now look back exactly one step, and can be
done away with. By adding a variable \konst{isInit}, we can get rid of \konst{Fby}
expressions (leaving only the one defining \konst{isInit}, which will get
removed in the next step):
%
{\small
\begin{verbatim}
  isInit = T -> F
    N = if isInit then 0 else 1 + pre N
  in2 = if isInit then 42 else pre in1
  in1 = if isInit then 42 else pre inVar
  inVar = input
   ap = if N <= 1 then
         T
       else
         pre(ap) and (input - in1 = in1 - in2)
\end{verbatim}
}
%
We now make the environment explicit and interpret $\konst{pre}(-)$ as
the identity function. The resulting step function is then a direct
transcription of the list of assignments.
%
{\small
\begin{verbatim}
  apStep : input * state -> state * output

  apStep ((input), (isInit,N,in2,in1,inVar,ap)) =
     let N = if isInit then 0 else 1 + N
         in2 = if isInit then 42 else in1
         in1 = if isInit then 42 else inVar
         inVar = input
         ap = if N <= 1 then T else ap and (input - in1 = in1 - in2)
      in
        ((F,N,in2,in1,inVar,ap), (ap))
\end{verbatim}
}

\section{Temporal squashing}

\section{Attaching decoders and encoders}

\section{Moving to CakeML}

\section{Infinite executions}

We have so far only addressed finite computations stemming from
{\agree} specifications. However, the intended behavior of components
generated by {\splat} is that they are perpetually re-invoked by a
real-time scheduler; thus we are interested in showing that such
executions are indeed infinite, and in showing properties of the
infinite executions. The work of \cite{johannes:repeatc} established a
proof rule for drawing such inferenced and our goal is to automate a
path from our {\agree} specifications to such theorems.


\section{Toolchain}

The code generation toolchain begins with an AADL model in the
BriefCase environment and ends with a CakeML-generated
executable. Here are the steps:
\begin{enumerate}
\item The user supplements the system {\aadl} model
  $\konst{MODEL}_\konst{AADL}$ with security components and specifies
  their behaviour in {\agree} annexes.
\item $\konst{MODEL}_\konst{AADL}$ is translated to JSON, yielding
  $\konst{MODEL}_\konst{JSON}$, which is exported to a file.
\item The \splat{} tool is invoked and reads in
  $\konst{MODEL}_\konst{JSON}$. (The following steps take place in
  {\splat}.)
\item The model is \emph{scraped} for security component declarations
  and specifications. These are mapped to component ASTs, which are
  processed independently. Assume we are dealing with a single such
  AST \konst{comp}. It specifies several things:
  \begin{itemize}
  \item the input and output ports (features) of \konst{comp};
  \item a computation---expressed as a sequence of equations---over
    the ports and a collection of state variables; and
  \item an Assume-Guarantee style contract.
  \end{itemize}
\item In many cases, the {\agree} model checker can establish that the
  computation of \konst{comp} satisfies its contract, but note that
  contracts can be arbitrarily complex. Therefore it can happen that a
  valid contract is not provable by the model checker. In such cases,
  our modelling approach can be used to generate formal definitions
  and goals that can be tackled in an interactive theorem prover. In
  either eventuality, the toolchain maps \konst{comp} into {\clustre}
  and uses a formal semantics of {\clustre} to derive a stream-valued
  function
  \[
  \konst{strmFn} : \konst{strmEnv} \to \konst{strmEnv}
  \]
  representing the behaviour of the component, where
  \[
  \konst{strmEnv} = \konst{string} \mapsto (\konst{nat} \to \konst{value})
  \]
\item The next step is to transform \konst{comp} so that the execution
  looks back at most one time unit in streams. We call this
  \emph{temporal squashing} (\konst{squash}). A temporally squashed component can
  only access the current or previous value of any variable, making it
  similar to an imperative implementation. We expect
  \[
  \vdash \sem{\konst{comp}} = \sem{\konst{squash}(\konst{comp})}
  \]
  to be provable.
\item Let $\konst{comp'} = \konst{squash}(\konst{comp})$. From \konst{comp'} we
\end{enumerate}

\begin{tikzpicture}[auto]
\node [cloud, draw, cloud puffs = 16, align=left] (SPEC) at (0,0) {Format \\ Specification};
\node [draw,align=left](TEST) at (-4,0) {test gen. \\ fuzzing};
\node [draw,align=left] (PROP) at (0,-3.5) {Semantics, \\ properties, proofs};
\node [draw, align=left] (IMPL) at (4.5,0) {Implementations: \\ recognizers, \\ parsers, \\ encode/decode};
\draw [->, ultra thick] (SPEC) to (TEST);
\draw [->, ultra thick] (SPEC) to (PROP)r
\draw [->, ultra thick] (SPEC) to (IMPL);
\end{tikzpicture}

\bibliography{agree}

\end{document}
