\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Semantics of AGREE}
\author{Konrad Slind}{Trusted Systems Group, Collins Aerospace, USA}{konrad.slind@collins.com}{}{}
\authorrunning{K. Slind}

\usepackage{holtexbasic}
\usepackage{alltt}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsbsy}

\newcommand{\ie}{\textit{i.e.}}
\newcommand{\eg}{\textit{e.g.}}
\newcommand{\etal}{\textit{et al.}}
\newcommand{\etc}{\textit{etc.}}
\newcommand{\adhoc}{\textit{ad hoc}}
\newcommand{\konst}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\imp}{\Rightarrow}
\newcommand{\lval}{\ensuremath{\mathit{lval}}}
\newcommand{\set}[1]{\ensuremath{\{ {#1} \}}}
\newcommand{\kstar}[1]{\ensuremath{{#1}^{*}}}
\newcommand{\Lang}[1]{\ensuremath{{\mathcal L}({#1})}}
\newcommand{\LangTheta}[1]{\ensuremath{{\mathcal L}_{\theta}({#1})}}
\newcommand{\SubstTheta}[2]{\ensuremath{\theta\;{#1}\; {#2}}}
\newcommand{\itelse}[3]{\mbox{$\mathtt{if}\ {#1}\ \mathtt{then}\ {#2}\ \mathtt{else}\ {#3}$}}
\newcommand{\agree}{\textsc{AGREE}}

\begin{document}

\maketitle


\begin{abstract} The {\agree} language is used to specify
behavior of AADL models. We define the semantics of {\agree} and
discuss how the semantics is leveraged to generate code that acts as a
witness to the specification.

\end{abstract}

\section{Introduction}\label{sec:intro}

\section{{\agree} syntax}\label{sec:syntax}

An {\agree} leaf-level \emph{component} is the element that we wish to
study. A component has a collection of input ports and output ports,
local state variable assignments, output port assignments, and, for
specification purposes, assumptions and guarantees. At runtime, a
component reads from its input ports, updates state variables, then
computes values for output ports. A component is represented by the
following record type:

\begin{HOLmath}
\HOLthm[m;,>>3]{agree.datatype_component}
\end{HOLmath}

 Assumptions are boolean expressions over the input ports, while
guarantees are boolean expressions that can refer to input port
values and the values of variables.  We will use the following
notation to describe a component:

\[
\begin{array}{rcll}
\multicolumn{3}{c}{A_1 \land \cdots \land A_i} & \text{; assumptions} \\
  v_1 & = & e_1 & \text{; variable definitions} \\
     & \cdots & & \\
 v_j & = & e_j &   \\
 o_1 & = & e_{j+1} & \text{; output definitions} \\
     & \cdots & &  \\
 o_k & = & e_{j+k} & \\
\multicolumn{3}{c}{G_1 \land \cdots \land G_m} & \text{; guarantees} \\
\end{array}
\]

\begin{remark}
For now, the sets of port variables and program variables are not
explicitly declared in the component declaration; instead, the set of
variables occurring in the component implicitly defines the input port
variables (arguments to \konst{PortVar}), program variables (left-hand
sides of variable assignments), and output port variables (left-hand
sides of output assignments).
\end{remark}


\subsection{Expressions and statements}

{\agree} expressions are conventional arithmetic/boolean expressions,
defined by a mutual recursion.

\begin{HOLmath}
\HOLthm[m;,>>3]{agree.datatype_expr}
\end{HOLmath}

There are also a few special aspects to note:

\begin{itemize}

\item There are three kinds of variable: \emph{port} variables are
  distinguished from \emph{program} variables. An input port variable
  holds the value of an input port, and is immutable; a program
  variable is a mutable location. Output port variables are mutable
  locations, the values of which are used as output of the component.

\item Lustre-style \verb+fby+ and \verb+pre+ operators help specify
  temporally-influenced behaviours. We also provide a
  \emph{Historically} operator (\verb+Hist+)

\end{itemize}

There is only one kind of statement: assignment.
\begin{HOLmath}
\HOLthm[m;,>>3]{agree.datatype_stmt}
\end{HOLmath}

\section{{\agree} semantics}\label{sec:semantics}

Component \emph{environments} are finite maps from a \emph{name} (port
name or variable name) to a stream of type $\tau$. Currently all
streams are of type \konst{int}. Thus

\[
  \konst{env} = \konst{string} \mapsto (\konst{nat} \to \konst{int})
\]

\begin{definition}[Environment update]

Variable assignment is modelled by updating the named stream in an
environment at a point in time:

\begin{HOLmath}
\HOLthm[m;,def,>>3]{agree.updateEnv_def}
\end{HOLmath}

\begin{remark}[Notation]
The expression \HOLtm{env ' name t} means `the value of variable
$\mathit{name}$ in environment $\mathit{env}$ at time $t$'.
\end{remark}

\end{definition}

\subsection{Expression valuation}

We employ separate environments for input ports ($\mathit{portEnv}$) and
program variables ($\mathit{varEnv}$). Following is the definition of
expression valuation in a $(\mathit{portEnv},\mathit{varEnv})$
environment at a time $t$. Some cases have been elided.
%
\begin{definition}[Expression values]

\begin{HOLmath}
\HOLthm[m;,def,>>3,conj1]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj2]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj3]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj4,width=75]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj9,width=95]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj10,width=95]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj11]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj13,width=75]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj14,width=75]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj18,width=75]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj19,width=75]{agree.exprVal_def} \\
\HOLthm[m;,def,>>3,conj21,width=75]{agree.exprVal_def} \\
\end{HOLmath}

\end{definition}

\begin{remark}[Partiality]
The semantics of \konst{PreExpr} requires that it is undefined at time
0. Because HOL does not support true undefinedness, we have used the
\konst{ARB} constant of HOL which is a polymorphic constant denoting a
fixed arbitrary element of its type (\konst{int}
currently). \konst{ARB} is useful for specification but it does not
have a computational value. We have considered using some fixed
integer---such as 42---instead, but that will not extend well to a
more complex type regime. Instead, we could make expression evaluation
explicitly partial, by using option types. We have done this in our
actual implementation, but for now we will stick with \konst{ARB}.
\end{remark}


\subsection{Statement value and effect}

The value of a statement $v = e$ is $(v,i)$ where $i$ is the value of $e$ in the current state.

\begin{HOLmath}
\HOLthm[m;,def,>>3]{agree.stmtVal_def}
\end{HOLmath}

The meaning of an assignment statement is a transformation on the environment:

\begin{definition}[Statement effect]

\begin{HOLmath}
\HOLthm[m;,def,>>3]{agree.stmtEffect_def}
\end{HOLmath}

In the following, lists of assignments need to be dealt with both sequentially (via a
\konst{fold} from the left) and also in parallel (via a \konst{map}
followed by an accumulating \konst{fold} from the right):

\begin{HOLmath}
\HOLthm[m;,def,>>3]{agree.stmtListEffect_def}

\\ \\

\HOLthm[m;,def,>>3]{agree.stmtListParEffect_def}
\end{HOLmath}

\end{definition}

\subsection{Component effect and correctness}

The \emph{effect} of a component is the environment obtained by
evaluating the variable assignments given the input port values. The
variable definitions are evaluated in sequence, and then the output
definitions are evaluated in parallel (ensuring that no output can
depend on any other output), and added to the bindings obtained from
the variable assignments.

\begin{HOLmath}
\HOLthm[m;,def,>>3,width=90]{agree.componentEffect_def}
\end{HOLmath}

We now have almost enough definitions to define correctness of a
component. We only need to extend the component behaviour through
time, and do this by iterating the effect of the component.

\begin{HOLmath}
\HOLthm[m;,def,>>3,width=85]{agree.iterateEffect_def}
\end{HOLmath}

Note that the component effect is not given, as one might expect, a
default value at time 0. The first input of the component arrives at
time 0, and thus there is also a computation and output at time 0.

Given values on the input ports, and the values for variables, the
\emph{contract} of the component can be expressed. The assumptions are
assumed to hold for all times up to the present, and the guarantees
need to hold at the present time.

\begin{HOLmath}
\HOLthm[m;,def,>>3,width=75]{agree.assumsVal_def}
\\ \\
\HOLthm[m;,def,>>3]{agree.guarsVal_def}
\end{HOLmath}

Finally, the correctness of a leaf-level component can be defined: the
component is correct if, for any time $t$, the guarantees hold after
iterating for $t+1$ steps, starting with an arbitrary initial state,
and providing that the assumptions hold.

\begin{HOLmath}
\HOLthm[m;,def,>>3]{agree.Component_Correct_def}
\end{HOLmath}


\section{Example}

\section{Code Generation}\label{sec:codegen}

\bibliography{agree}

\end{document}
