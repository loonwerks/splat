Basic example of CakeML and its FFI interface.
-----------------------------------------------

This directory has the following files:

   $ ls
   basis_ffi.c  cake.lib  cake.S  Makefile  README  test.cml

  cake.lib    - documentation for the library functions available in CakeML
  cake.S      - CakeML compiler (assembly)
  Makefile    - builds executables
  basis_ffi.c - C implementations of foreign functions
  test.cml    - simple examples, first just calls the "cos" function from the C math library,
                second takes two args, and calls cos on the first, sin on the second,
		returns a pair of results.

To build an executable:

  $ make
  cc    -c -o cake.o cake.S
  cc    -c -o basis_ffi.o basis_ffi.c
  cc  cake.o basis_ffi.o  -lm -o cake
  ./cake  <test.cml >test.cake.S
  cc  test.cake.S basis_ffi.o  -lm -o test.cake
  rm test.cake.S

For our example file---test.cml---The executable is the file test.cake. To run it:

  $ ./test.cake
  Test 1.
  Input (radians) : 0.0021816597222222219865
  Cos             : 0.99999762018137217101

  Test 2.
  Input1 (radians) : 0.0021816597222222219865
  Cos              : 0.99999762018137217101

  Input2           : 17.026719668888887327
  Sine             : -0.96840572036184568994


Discussion.
-----------

 On the CakeML side, an FFI call has the form

  #(fn-name) string buf

where the string holds the flattened arguments to the call, and buf is
a byte array that holds the result of the FFI.

The C implementation of the desired function has to handle
four arguments:

   a. a string that holds the inputs for the FFI call
   b. an integer giving the length of the string
   c. a byte buffer to store the results
   d. an integer giving the length of the byte buffer.

 For a CakeML FFI invocation

   #(foo) string buf

the corresponding C implementation in basis_ffi.c has the general form

   void ffifoo (unsigned char *input, long ilen,
                unsigned char *output, long olen) { <body> }


Inside <body> there has to be some boilerplate code that unpacks the
input string into C values; then the actual computation happens,
yielding results; then the results are packed into the output
buffer. Following is the first example in test.cml, which takes the
"cos" of a single double value.

   void ffiradcos(unsigned char *input, long ilen,
                  unsigned char *output, long olen) {
     assert (8 == ilen);  /* check input size */

     double arg = *((double*)input); /* cast input to a double */
     double result = cos(arg);       /* run cos on input */
     /* copy result to output buffer */
     memcpy(output, (unsigned char*) &result, sizeof(double));
   }

A later example in test.cml shows how mutiple arguments are packed and
unpacked.
