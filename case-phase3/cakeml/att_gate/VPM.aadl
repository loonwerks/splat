--Copyright ï¿½ 2021 Rockwell Collins, Inc., a part of Collins Aerospace
package VPM
public

	with LRUs,Processors,Memories;
	with Busses;
	with DTU_Types;
	with ADSB_Types;
	with CASE_Proxies;
	with Base_Types;
	with Data_Model;
	with CASE_Properties;
	with CASE_AGREE; renames CASE_AGREE::all;
	with HAMR;
	
	data Adapter_Connection_Control_Message
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Base_Types::Unsigned_8));
			Data_Model::Dimension => (2048);
	end Adapter_Connection_Control_Message;

	data implementation Adapter_Connection_Control_Message.impl
		properties
			HAMR::Bit_Codec_Max_Size => 2048 Bytes;
	end Adapter_Connection_Control_Message.impl;
	
	thread adapter_high
		-- automagically generated
		features
			-- external features
			SHM_Queue_In: in event data port CASE_Proxies::SHM_Queue_Element.impl;
			SHM_Queue_Out: out event data port CASE_Proxies::SHM_Queue_Element.impl;
			
			-- internal features
			Adapter_Connection_Control_In: in event data port Adapter_Connection_Control_Message.impl;
			Adapter_Connection_Control_Out: out event data port Adapter_Connection_Control_Message.impl;
			ADSB_Aggregated_Message_Out: out event data port ADSB_Types::ADSB_Aggregated_Message.impl;
			VDTU_Request_Message_In: in event data port CASE_Proxies::SHM_Queue_Element.impl[16];
			VDTU_Response_Message_Out: out event data port CASE_Proxies::VDTU_Message_Block.impl;
			
    	properties
			Dispatch_Protocol => Periodic;
			Compute_Execution_Time => 10ms .. 50ms;
			Period => 250ms;
	end adapter_high;
	
	thread implementation adapter_high.impl
	end adapter_high.impl;
	
	thread adapter_low
		-- automagically generated
		features
			-- external features
			SHM_Queue_In: in event data port CASE_Proxies::SHM_Queue_Element.impl;
			SHM_Queue_Out: out event data port CASE_Proxies::SHM_Queue_Element.impl;			
			
			-- internal features
			Adapter_Connection_Control_In: in event data port Adapter_Connection_Control_Message.impl;
			Adapter_Connection_Control_Out: out event data port Adapter_Connection_Control_Message.impl;
			ADSB_Aggregated_Message_In: in event data port ADSB_Types::ADSB_Aggregated_Message.impl;
			ADSB_Suspect_IDs_Message_In1: in event data port ADSB_Types::MonitorReport.impl;
			ADSB_Suspect_IDs_Message_In2: in event data port ADSB_Types::MonitorReport.impl;
			ADSB_Suspect_IDs_Message_In3: in event data port ADSB_Types::MonitorReport.impl;
			Attestation_Request_Message_In: in event data port Attestation_Request_Message.impl;
			Attestation_Response_Message_Out: out event data port Attestation_Response_Message.impl;
			Initiate_Attestation: out event data port Case_Proxies::IPv4;
			Terminate_Attestation: in event port;
			VDTU_Response_Message_In: in event data port CASE_Proxies::VDTU_Message_Block.impl;
			VDTU_Request_Message_Out: out event data port CASE_Proxies::SHM_Queue_Element.impl[16];
    	properties
			Dispatch_Protocol => Periodic;
			Compute_Execution_Time => 10ms .. 50ms;
			Period => 500ms;
	end adapter_low;
	
	thread implementation adapter_low.impl
	end adapter_low.impl;
	
	--------------------------------------------------
	-- Expected Position Monitor
	--------------------------------------------------
--	thread CASE_Monitor1
--		features
--			Observed: in event data port ADSB_Types::ADSB_Aggregated_Message.impl;
--			Suspect_Traffic_Out: out event data port ADSB_Types::MonitorReport.impl;
--		properties
--			CASE_Properties::Monitoring => 100;
--			CASE_Properties::Component_Language => CakeML;
--			CASE_Properties::Component_Spec => ("CASE_Monitor1_Suspect_Traffic_Out");
--			Dispatch_Protocol => Periodic;
--			Compute_Execution_Time => 10ms .. 50ms;
--			Period => 500ms;
--		annex agree {**
--			const is_latched : bool = false;
--			const MONITOR_ID : int = 1;
			
			-- Uninterpreted function
--			type state_bounds = struct {hVel_lower: real, hVel_upper: real, beta_lower: real, beta_upper: real, vVel_lower: real, vVel_upper: real};
			
--			uninterpreted calculateBoundaries(prev_lat: real, curr_lat: real, prev_long: real, curr_long: real, prev_alt: real, curr_alt: real) : state_bounds;
			
			-- TODO: ask Jeremy about >= vs >
--			fun BOUNDS_VIOLATION(now : ADSB_Types::TrafficReport.impl, yest : ADSB_Types::TrafficReport.impl, bounds : state_bounds) : bool = 
--				real(now.HorizontalVelocity) < bounds.hVel_lower
--	            or real(now.HorizontalVelocity) >= bounds.hVel_upper 
--	            or real(now.VerticalVelocity) <= bounds.vVel_lower
--	            or real(now.VerticalVelocity) >= bounds.vVel_upper
--	            or now.TrackHeading <= bounds.beta_lower
--	            or now.TrackHeading >= bounds.beta_lower;
--				
--	         -- The "now" traffic report is unexpcted given the "yest" report
--	         fun UNEXPECTED (now : ADSB_Types::TrafficReport.impl, yest : ADSB_Types::TrafficReport.impl) : bool = 
--             	(now.TargetIdentity = yest.TargetIdentity)
--             	and
--             	BOUNDS_VIOLATION (now, yest,
--            		calculateBoundaries(yest.Latitude, now.Latitude, yest.Longitude, now.Longitude, real(yest.Altitude), real(now.Altitude)));
	             
--	        eq Today : ADSB_Types::TrafficReportArray = Observed.Traffic;
	
--	        eq Yesterday : ADSB_Types::TrafficReportArray = (Observed.Traffic -> pre (Today));
	             
		    -- false in the first step since there are no previous measurements to compare against then
--		    eq abnormal : bool = (false -> (exists now in Today, exists yest in Yesterday, UNEXPECTED(now,yest))); 
			 
--	        fun SUSPECT_IDS (today : ADSB_Types::TrafficReportArray, yesterday : ADSB_Types::TrafficReportArray) : ADSB_Types::TargetIdentityArray = 
--					flatmap i in indices(today),
--					      [| if (exists yest in yesterday, UNEXPECTED (today[i], yest)) 
--					      	    then (today[i]).TargetIdentity
--					      	    else DEFAULT_TARGET_ID |]; 
          		
--          	guarantee CASE_Monitor1_Suspect_Traffic_Out 
--		  		"Output duplicated IDs in traffic reports" : 
--		     		if event(Observed) and abnormal then 
--		        		event (Suspect_Traffic_Out) and 
--		        		(Suspect_Traffic_Out = MK_MONITOR_REPORT(MONITOR_ID, SUSPECT_IDS(Today,Yesterday)))
--		     		else not(event(Suspect_Traffic_Out));
--		     			
--			**};
--	end CASE_Monitor1;

--	thread implementation CASE_Monitor1.Impl
--	end CASE_Monitor1.Impl;
	
	--------------------------------------------------
	-- Duplicate Entity Monitor
	--------------------------------------------------
--	thread CASE_Monitor2
--		features
--			Observed: in event data port ADSB_Types::ADSB_Aggregated_Message.impl;
--			Suspect_Traffic_Out: out event data port ADSB_Types::MonitorReport.impl;
--		properties
--			CASE_Properties::Monitoring => 100;
--			CASE_Properties::Component_Language => CakeML;
--			CASE_Properties::Component_Spec => ("CASE_Monitor2_Suspect_Traffic_Out");
--			Dispatch_Protocol => Periodic;
--			Compute_Execution_Time => 10ms .. 50ms;
--			Period => 500ms;
--		annex agree {**
--			const is_latched : bool = false;
--			const MONITOR_ID : int = 2; 
			
--			fun IS_DUPLICATE_ID (traffic1 : ADSB_Types::TrafficReport.impl, traffic2 : ADSB_Types::TrafficReport.impl) : bool =
--				traffic1.TargetIdentity = traffic2.TargetIdentity and
--				not(traffic1.TargetIdentity = DEFAULT_TARGET_ID);
						
--			fun IS_DUPLICATE_TRAFFIC (msg : ADSB_Types::ADSB_Aggregated_Message.impl, index : int) : bool =
--				exists dup_index in indices(msg.Traffic), 
--					not(dup_index = index) and
--					IS_DUPLICATE_ID(msg.Traffic[index], msg.Traffic[dup_index]);
					
--			fun IS_DUPLICATE_OWNSHIP (msg : ADSB_Types::ADSB_Aggregated_Message.impl, index : int) : bool =
--				IS_DUPLICATE_ID(msg.Ownship, msg.Traffic[index]);
				
--			fun DUPLICATE_IN_REPORT (msg : ADSB_Types::ADSB_Aggregated_Message.impl) : bool = 
--				exists index in indices(msg.Traffic), IS_DUPLICATE_TRAFFIC(msg, index) or IS_DUPLICATE_OWNSHIP(msg, index);
				
--			fun SUSPECT_IDS (msg : ADSB_Types::ADSB_Aggregated_Message.impl) : ADSB_Types::TargetIdentityArray = 
--				flatmap i in indices(msg.Traffic), 
--					[| if IS_DUPLICATE_TRAFFIC(msg, i) or IS_DUPLICATE_OWNSHIP(msg, i) then 
--					      (msg.Traffic[i]).TargetIdentity
--					   else DEFAULT_TARGET_ID |];
					   
--			guarantee CASE_Monitor2_Suspect_Traffic_Out
--			  "Output duplicated IDs in traffic reports" : 
--			     if event(Observed) and DUPLICATE_IN_REPORT(Observed) then 
--			        event (Suspect_Traffic_Out) and 
--			        (Suspect_Traffic_Out = MK_MONITOR_REPORT(MONITOR_ID, SUSPECT_IDS(Observed)))
--			     else not(event(Suspect_Traffic_Out));

--			**};
--	end CASE_Monitor2;

--	thread implementation CASE_Monitor2.Impl
--	end CASE_Monitor2.Impl;
	
	--------------------------------------------------
	-- Teleport Monitor
	--------------------------------------------------
--	thread CASE_Monitor3
--		features
--			Observed: in event data port ADSB_Types::ADSB_Aggregated_Message.impl;
--			Suspect_Traffic_Out: out event data port ADSB_Types::MonitorReport.impl;
--		properties
--			CASE_Properties::Monitoring => 100;
----			CASE_Properties::Component_Language => CakeML;
--			CASE_Properties::Component_Spec => ("CASE_Monitor3_Suspect_Traffic_Out");
--			Dispatch_Protocol => Periodic;
--			Compute_Execution_Time => 10ms .. 50ms;
--			Period => 500ms;
--		annex agree {**
--			const is_latched : bool = false;
--			const MONITOR_ID : int = 3; 
					
--			const LATITUDE_DELTA : real = 1.0; -- degree
--			const LONGITUDE_DELTA : real = 1.0; -- degree
--			const ALTITUDE_DELTA : ADSB_Types::Altitude_Type = 2000; -- feet
			
--			fun IN_ZONE_A (ownship : ADSB_Types::TrafficReport.impl, ship : ADSB_Types::TrafficReport.impl) : bool =
--				(ship.Latitude >= ( ownship.Latitude - LATITUDE_DELTA) ) and
--				(ship.Latitude <= ( ownship.Latitude + LATITUDE_DELTA) ) and
--				(ship.Longitude >= ( ownship.Longitude - LONGITUDE_DELTA) ) and
--				(ship.Longitude <= ( ownship.Longitude + LONGITUDE_DELTA) ) and
--				(ship.Altitude >= ( ownship.Altitude - ALTITUDE_DELTA) ) and
--				(ship.Altitude <= ( ownship.Altitude + ALTITUDE_DELTA));
--			
			-- is a ship in a traffic report array
--			fun PRESENT(ship: ADSB_Types::TrafficReport.impl, reports : ADSB_Types::TrafficReportArray) : bool =
--				exists elt in reports, ship.TargetIdentity = elt.TargetIdentity;
				
			-- is ship2 in Zone A of ship1 (the ownship) and also not present in previous
--            fun SUSPECT (ship1 : ADSB_Types::TrafficReport.impl, ship2 : ADSB_Types::TrafficReport.impl, previous: ADSB_Types::TrafficReportArray) : bool = 
--				   IN_ZONE_A (ship1, ship2) and not (PRESENT (ship2, previous));	

--            eq Today : ADSB_Types::TrafficReportArray = Observed.Traffic;
            
--            eq Yesterday : ADSB_Types::TrafficReportArray = (Observed.Traffic -> pre (Today));
             
            -- true iff there is a suspicious traffic report in Observed.Traffic
--     	    eq abnormal : bool = (false -> (exists ship in Observed.Traffic, SUSPECT(Observed.Ownship, ship, Yesterday))); 

--            fun SUSPECT_IDS (ownship : ADSB_Types::TrafficReport.impl, traffic : ADSB_Types::TrafficReportArray, previous : ADSB_Types::TrafficReportArray) :  ADSB_Types::TargetIdentityArray = 
--				flatmap i in indices(traffic),
--				      [| if SUSPECT (ownship, traffic[i], previous)
--				      	    then (traffic[i]).TargetIdentity 
--				      	    else DEFAULT_TARGET_ID |];

--			guarantee CASE_Monitor_Suspect_Traffic_Out 
--			  "Output duplicated IDs in traffic reports" : 
--			     if event(Observed) and abnormal then 
--			        event (Suspect_Traffic_Out) 
--			        and 
--			        (Suspect_Traffic_Out = 
--			        	MK_MONITOR_REPORT (MONITOR_ID, SUSPECT_IDS (Observed.Ownship, Observed.Traffic, Yesterday)))
--			     else not(event(Suspect_Traffic_Out));	   	
	
--			**};
--	end CASE_Monitor3;

--	thread implementation CASE_Monitor3.Impl
--	end CASE_Monitor3.Impl;
	
	data Attestation_Request_Message	
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Base_Types::Unsigned_8));
			Data_Model::Dimension => (16);
	end Attestation_Request_Message;

	data implementation Attestation_Request_Message.impl
		properties
			HAMR::Bit_Codec_Max_Size => 16 Bytes;
	end Attestation_Request_Message.impl;
	
	data Attestation_Response_Message	
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Base_Types::Unsigned_8));
			Data_Model::Dimension => (2048);
	end Attestation_Response_Message;

	data implementation Attestation_Response_Message.impl
		properties
			HAMR::Bit_Codec_Max_Size => 2048 Bytes;
	end Attestation_Response_Message.impl;
	
	data AllowedElement
		properties
			Data_Model::Data_Representation => Struct;
	end AllowedElement;
	
	data implementation AllowedElement.impl
		subcomponents
			protocol: data Base_Types::Unsigned_32;
			remote_address: data CASE_Proxies::IPv4;
		properties
			HAMR::Bit_Codec_Max_Size => 8 Bytes;	
	end AllowedElement.impl;
	
	data AllowList
		properties
            Data_Model::Data_Representation => Array;
            Data_Model::Base_Type => (classifier (AllowedElement.impl));
            Data_Model::Dimension => (4);
	end AllowList;
	
	data implementation AllowList.impl
		properties
			HAMR::Bit_Codec_Max_Size => 32 Bytes;
	end AllowList.impl;
	
	--------------------------------------------------
	-- Attestation Manager
	--------------------------------------------------
	thread CASE_AttestationManager
		features
			Attestation_Request: out event data port Attestation_Request_Message.impl;
			Attestation_Response: in event data port Attestation_Response_Message.impl;
			Trusted_IDs: out event data port AllowedElement.impl[4];
			
			Initiate_Attestation: in event data port CASE_Proxies::IPv4;
			Terminate_Attestation: out event port;
		properties
			CASE_Properties::Attesting => 100;
			Dispatch_Protocol => Periodic;
			Compute_Execution_Time => 10ms .. 50ms;
			Period => 500ms;
	end CASE_AttestationManager;

	thread implementation CASE_AttestationManager.Impl
		properties
			CASE_Properties::Cache_Timeout => 5 min;
			CASE_Properties::Cache_Size => 4;
	end CASE_AttestationManager.Impl;
	
	--------------------------------------------------
	-- Attestation Gate
	--------------------------------------------------
	thread CASE_AttestationGate
		features
		Trusted_IDs            : in event data port AllowedElement.impl[4];
		VDTU_Request_Message_In: in event data port CASE_Proxies::SHM_Queue_Element.impl[16];
		VDTU_Request_Message_Out: out event data port CASE_Proxies::SHM_Queue_Element.impl[16];
	
	properties
		CASE_Properties::Gating => 100;
--		CASE_Properties::Component_Language => CakeML;
        CASE_Properties::Component_Spec => ("CASE_Attestation_Gate_Policy");
		Dispatch_Protocol => Periodic;
		Compute_Execution_Time => 10ms .. 50ms;
		Period => 500ms;
	annex agree {**
        const DEFAULT_PAYLOAD : Base_Types::Unsigned_8[2016] = 
             [| 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 |];
		
		const DEFAULT_IP : CASE_Proxies::IPv4 = [| 0, 0, 0, 0 |];

        const DEFAULT_TAG : Base_Types::Unsigned_32 = 0;
        
        const DEFAULT_CONNECTION_DATA : CASE_Proxies::connection_data.impl = 
            CASE_Proxies::connection_data.impl 
               {local_address = DEFAULT_IP;  local_port = 0; 
               	remote_address = DEFAULT_IP; remote_port = 0
               };
            		
		const DEFAULT_SHM_ELEMENT : CASE_Proxies::SHM_Queue_Element.impl = 
		  CASE_Proxies::SHM_Queue_Element.impl {
		  	 length = 0;
		     tag = DEFAULT_TAG;
		     protocol = 0;
		     command = 0;
		     connection_data = DEFAULT_CONNECTION_DATA;
		     payload = DEFAULT_PAYLOAD
		  };
		
-- Declared in AADL for now, due to bug in json-generation for AGREE struct decls
--		type TAG_IP_Pair = struct {tag : Base_Types::Unsigned_32, IP : CASE_Proxies::IPv4};
		
		const DEFAULT_TAG_IP_Pair    : TAG_IP_Pair.impl    =    TAG_IP_Pair.impl {tag = DEFAULT_TAG; IP = DEFAULT_IP; valid = false};
        const DEFAULT_TAG_VALID_PAIR : TAG_VALID_PAIR.impl = TAG_VALID_PAIR.impl {tag = DEFAULT_TAG; valid = false};
		
		const DEFAULT_TAG_MAP : TAG_IP_Pair.impl[16] = 
		      [|DEFAULT_TAG_IP_Pair, DEFAULT_TAG_IP_Pair, DEFAULT_TAG_IP_Pair, DEFAULT_TAG_IP_Pair, 
		      	DEFAULT_TAG_IP_Pair, DEFAULT_TAG_IP_Pair, DEFAULT_TAG_IP_Pair, DEFAULT_TAG_IP_Pair, 
		      	DEFAULT_TAG_IP_Pair, DEFAULT_TAG_IP_Pair, DEFAULT_TAG_IP_Pair, DEFAULT_TAG_IP_Pair, 
		      	DEFAULT_TAG_IP_Pair, DEFAULT_TAG_IP_Pair, DEFAULT_TAG_IP_Pair, DEFAULT_TAG_IP_Pair |];
		
		const DEFAULT_ALLOW_LIST_ELEMENT : AllowedElement.impl = 
		      AllowedElement.impl {protocol = 0; remote_address = DEFAULT_IP};

		const DEFAULT_ALLOW_LIST : AllowedElement.impl[4] = 
		      [| DEFAULT_ALLOW_LIST_ELEMENT, DEFAULT_ALLOW_LIST_ELEMENT, 
		      	 DEFAULT_ALLOW_LIST_ELEMENT, DEFAULT_ALLOW_LIST_ELEMENT |];

       -- Some membership functions 		

		fun FOUND_IN_TAGS(tag_ip : TAG_IP_Pair.impl, tags : TAG_VALID_PAIR.impl[16]) : bool =
			exists i in tags, i.tag = tag_ip.tag and i.valid = tag_ip.valid;
			
	    fun FOUND_IN_TAG_MAP(tag_ip : TAG_IP_Pair.impl, map : TAG_IP_Pair.impl[16]) : bool =
			exists i in map, tag_ip = i;

		-- returns true if a tag is found in a tap-ip array
		fun FOUND_TAG_IN_TAG_MAP(tag : Base_Types::Integer_32, map : TAG_IP_Pair.impl[16]) : bool =
			exists i in map, i.tag = tag;

		fun FOUND_IN_WHITELIST(whitelist : AllowedElement.impl[4], ip : CASE_Proxies::IPv4) : bool =
			exists elt in whitelist, elt.remote_address = ip;

		-- returns a tag-ip array that is a copy of map1 except for those elements of map1 that 
		-- are in map2 (replaced with default tag-ip pairs)
		fun REMOVE_DUPLICATE_TAG_IP_PAIRS(map1 : TAG_IP_Pair.impl[16], map2: TAG_IP_Pair.impl[16]) : TAG_IP_Pair.impl[16] =
			flatmap i in map1, [| if FOUND_IN_TAG_MAP(i, map2) then DEFAULT_TAG_IP_Pair else i |];
			
		-- functions to check command types
		fun IS_DATA   (msg : CASE_Proxies::SHM_Queue_Element.impl) : bool = msg.command = 1;
		fun IS_CONNECT(msg : CASE_Proxies::SHM_Queue_Element.impl) : bool = msg.command = 2;
		fun IS_CLOSE  (msg : CASE_Proxies::SHM_Queue_Element.impl) : bool = msg.command = 3; 
		
		------------------------------------------
		-- read whitelist from attestation manager
		------------------------------------------

--      SPLAT currently only understands an expansion of the following:
--
--		eq whitelist : AllowedElement.impl[4] = if event(Trusted_IDs) then Trusted_IDs else prev(whitelist, DEFAULT_ALLOW_LIST);

		eq whitelist : AllowedElement.impl[4] = 
		   (if event(Trusted_IDs) then Trusted_IDs else DEFAULT_ALLOW_LIST)
		   ->
		   (if event(Trusted_IDs) then Trusted_IDs else pre(whitelist));

		---------------------------------------------
		-- internal cache of whitelisted tag-ip pairs
		---------------------------------------------
		
		-- cached tag-ip array
		eq previous_tag_map : TAG_IP_Pair.impl[16] = DEFAULT_TAG_MAP -> pre(tag_map_wo_close);
		
		-- create new tag-ip array in the following steps:
		-- a1 : new tag-ip array from VDTU_Request_Message_In filtered by messages that represent a Connect command
		-- a2 : remove entries from a1 that already exist in previous_tag_map
		-- a3 : combine a2 with previous_tag_map
		-- a4 : filter a3 using the whitelist
		eq tag_map : TAG_IP_Pair.impl[16] =
			if event(VDTU_Request_Message_In)
				then FILTER_BY_WHITELIST
				        (MERGE_TAG_MAPS
				           (previous_tag_map, 
				        	REMOVE_DUPLICATE_TAG_IP_PAIRS
				        	    (GET_NEW_TAGS_FROM_SHM_QUEUE(VDTU_Request_Message_In), previous_tag_map)), 
				         whitelist)
				else FILTER_BY_WHITELIST(previous_tag_map, whitelist);
		
		-- create new tag-ip array in the following steps:
		-- a1 : new tag array from VDTU_Request_Message_In filtered by messages that represent a Close command
		-- a2 : remove entries from tag_map that have a corresponding tag in a1
		eq tag_map_wo_close : TAG_IP_Pair.impl[16] =
			if event(VDTU_Request_Message_In)
				then REMOVE_DUPLICATE_TAGS
				       (tag_map, 
				       	GET_STALE_TAGS_FROM_SHM_QUEUE(VDTU_Request_Message_In))
				else tag_map;
		
		---------------------------------------------------------------
		-- helper functions for updating internal cache of tag-ip pairs
		---------------------------------------------------------------

		-- returns a count of the "holes" in the tag-ip array from the start of 
		-- the array to index "top" (inclusive)
		fun COUNT_HOLES(map : TAG_IP_Pair.impl[16], hole: TAG_IP_Pair.impl, top : int) : int = 
			foldl i in indices(map) into count = 0, if i <= top and map[i] = hole then count + 1 else count;
		
		-- returns a count of the elements (i.e. non-holes) in the tag-ip array 
		-- from the start of the array to index "top" (inclusive)
		fun COUNT_ELEMENTS(map : TAG_IP_Pair.impl[16], hole: TAG_IP_Pair.impl, top : int) : int = 
			foldl i in indices(map) into count = 0, if i <= top and map[i] <> hole then count + 1 else count;
		
		-- returns the index of the nth element (i.e. non-hole) in the tag-ip array
		fun GET_NTH_ELEM(map : TAG_IP_Pair.impl[16], n : int) : int =
			if (COUNT_ELEMENTS(map, DEFAULT_TAG_IP_Pair, 16) < n)
				then 0
				else foldl i in indices(map) into index = 0, 
				          if COUNT_ELEMENTS(map, DEFAULT_TAG_IP_Pair, i) = n then i else index;

		-- helper function for MERGE_TAG_MAPS
		fun ITE(index : int, map : TAG_IP_Pair.impl[16], default: TAG_IP_Pair.impl) : TAG_IP_Pair.impl = 
			if (index > 0 and index <= 16) then map[index] else default;
		
		-- merging of two tag-ip arrays
		-- broadly: fill each hole in map1, with an element in map2
		fun MERGE_TAG_MAPS(map1 : TAG_IP_Pair.impl[16], map2: TAG_IP_Pair.impl[16]) : TAG_IP_Pair.impl[16] =
			flatmap i in indices(map1),
			[| if (map1[i] <> DEFAULT_TAG_IP_Pair)
				then map1[i]
				else ITE(GET_NTH_ELEM(map2, COUNT_HOLES(map1, DEFAULT_TAG_IP_Pair, i)), map2, DEFAULT_TAG_IP_Pair)
			|];
		
		-- returns a tag-ip array that is a copy of map except for those elements whose tags exist in the array "tags" (re		
		fun REMOVE_DUPLICATE_TAGS(map: TAG_IP_Pair.impl[16], tags : TAG_VALID_PAIR.impl[16]) : TAG_IP_Pair.impl[16] =
			flatmap i in map, [| if FOUND_IN_TAGS(i, tags) then DEFAULT_TAG_IP_Pair else i |];
		
		-- returns a tag-ip array with a tag-ip pair for each Connect command in msgs (and default tag-ip pairs for the rest)
		fun GET_NEW_TAGS_FROM_SHM_QUEUE(msgs : CASE_Proxies::SHM_Queue_Element.impl[16]) : TAG_IP_Pair.impl[16] =
			flatmap i in msgs, 
			  [| if IS_CONNECT(i) then 
			  	    TAG_IP_Pair.impl {tag = i.tag; IP = i.connection_data.remote_address; valid = true} 
			  	 else DEFAULT_TAG_IP_Pair |];
				
		-- returns a tag array with a tag for each Close command in msgs (and zeroes for the rest)
		fun GET_STALE_TAGS_FROM_SHM_QUEUE(msgs : CASE_Proxies::SHM_Queue_Element.impl[16]) : TAG_VALID_PAIR.impl[16] =
			flatmap i in msgs, [| if IS_CLOSE(i) then TAG_VALID_PAIR.impl {tag = i.tag; valid = true} else DEFAULT_TAG_VALID_PAIR |];
		
		fun FILTER_BY_WHITELIST(map : TAG_IP_Pair.impl[16], whitelist : AllowedElement.impl[4]) : TAG_IP_Pair.impl[16] =
			flatmap i in map,
				[|
					if i.valid and FOUND_IN_WHITELIST(whitelist, i.IP) 
						then i 
		 				else DEFAULT_TAG_IP_Pair
		 		|];

		-- returns true if there exists an index in the block for which a close command precedes an element with a matching tag and a particular index
		fun CLOSE_PRECEDES_DATA(block : CASE_Proxies::SHM_Queue_Element.impl[16], tag: Base_Types::Unsigned_32, index: int) : bool =
			exists i in indices(block), 
			    IS_CLOSE(block[i]) and (block[i]).tag = tag and i < index;
					
		-- returns an array of messages: for each valid data command message, return the message; for the rest return a default shm message
		-- a valid data command message is defined as one that contains a tag for which an entry exists in tag_map
		fun UPDATE_BLOCK(block : CASE_Proxies::SHM_Queue_Element.impl[16], tag_map : TAG_IP_Pair.impl[16]) : CASE_Proxies::SHM_Queue_Element.impl[16] =
			flatmap i in indices(block), 
			[| if ((IS_DATA(block[i]) and not(CLOSE_PRECEDES_DATA(block, (block[i]).tag, i)))
                   or IS_CONNECT(block[i]) 
                   or IS_CLOSE(block[i])
                  )
                  and FOUND_TAG_IN_TAG_MAP((block[i]).tag, tag_map)
               then block[i]
               else DEFAULT_SHM_ELEMENT |];
			
		guarantee CASE_Attestation_Gate_Policy "Only messages from trusted sources shall be forwarded" : 
			if event(VDTU_Request_Message_In) 
				then event(VDTU_Request_Message_Out) and 
				     VDTU_Request_Message_Out = UPDATE_BLOCK(VDTU_Request_Message_In, tag_map)
			else not(event(VDTU_Request_Message_Out));
		**};
	end CASE_AttestationGate;


	thread implementation CASE_AttestationGate.Impl
	end CASE_AttestationGate.Impl;
	
	
data TAG_IP_Pair    properties Data_Model::Data_Representation => Struct; end TAG_IP_Pair;
data TAG_VALID_PAIR properties Data_Model::Data_Representation => Struct; end TAG_VALID_PAIR;
	 
data implementation TAG_IP_Pair.impl
subcomponents
 tag : data Base_Types::Unsigned_32;
  IP : data CASE_Proxies::IPv4;
  valid : data Base_Types::Boolean;
end TAG_IP_Pair.impl;

data implementation TAG_VALID_PAIR.impl
subcomponents
    tag : data Base_Types::Unsigned_32;
  valid : data Base_Types::Boolean;
end TAG_VALID_PAIR.impl;


	process SW
		features
			SHM_Queue_In: in event data port CASE_Proxies::SHM_Queue_Element.impl;
			SHM_Queue_Out: out event data port CASE_Proxies::SHM_Queue_Element.impl;
	end SW;
	
	process implementation SW.impl
		subcomponents
			adapter_high: thread adapter_high.impl;
			adapter_low: thread adapter_low.impl;
			
--			Expected_Position_Monitor: thread CASE_Monitor1.impl;
--			Duplicate_Entity_Monitor: thread CASE_Monitor2.impl;
--			Teleport_Monitor: thread CASE_Monitor3.impl;
			Attestation_Manager: thread CASE_AttestationManager.impl;
			Attestation_Gate: thread CASE_AttestationGate.impl;
		connections
			c1: port SHM_Queue_In -> adapter_high.SHM_Queue_In;
			c2: port adapter_high.SHM_Queue_Out -> SHM_Queue_Out;
			c3: port SHM_Queue_In -> adapter_low.SHM_Queue_In;
			c4: port adapter_low.SHM_Queue_Out -> SHM_Queue_Out;
--			c5: port adapter_high.ADSB_Aggregated_Message_Out -> Expected_Position_Monitor.Observed;
--			c6: port adapter_high.ADSB_Aggregated_Message_Out -> Duplicate_Entity_Monitor.Observed;
--			c7: port adapter_high.ADSB_Aggregated_Message_Out -> Teleport_Monitor.Observed;
			c8: port adapter_high.ADSB_Aggregated_Message_Out -> adapter_low.ADSB_Aggregated_Message_In;
--			c9: port Expected_Position_Monitor.Suspect_Traffic_Out -> adapter_low.ADSB_Suspect_IDs_Message_In1;
--			c10: port Duplicate_Entity_Monitor.Suspect_Traffic_Out -> adapter_low.ADSB_Suspect_IDs_Message_In2;
--			c11: port Teleport_Monitor.Suspect_Traffic_Out -> adapter_low.ADSB_Suspect_IDs_Message_In3;
			c12: port Attestation_Manager.Attestation_Request -> adapter_low.Attestation_Request_Message_In;
			c13: port adapter_low.Attestation_Response_Message_Out -> Attestation_Manager.Attestation_Response;
			c14: port Attestation_Manager.Trusted_IDs -> Attestation_Gate.Trusted_IDs;
			c15: port adapter_low.VDTU_Request_Message_Out -> Attestation_Gate.VDTU_Request_Message_In;
			c16: port Attestation_Gate.VDTU_Request_Message_Out -> adapter_high.VDTU_Request_Message_In;
			c17: port adapter_high.VDTU_Response_Message_Out -> adapter_low.VDTU_Response_Message_In;
			c18: port adapter_high.Adapter_Connection_Control_Out -> adapter_low.Adapter_Connection_Control_In;
			c19: port adapter_low.Adapter_Connection_Control_Out -> adapter_high.Adapter_Connection_Control_In;	
			c20: port adapter_low.Initiate_Attestation -> Attestation_Manager.Initiate_Attestation;
			c21: port Attestation_Manager.Terminate_Attestation -> adapter_low.Terminate_Attestation;
	end SW.impl;
	
	
	system VPM_8600B_Ext extends LRUs::VPM_8600B
		features
			Eth_Conn: requires bus access Busses::IEEE_802_3.impl;
			
			ADSB_Heartbeat_In: in event data port ADSB_Types::HeartBeat_Message.impl;
			ADSB_Ownship_In: in event data port ADSB_Types::TrafficReport.impl;
			ADSB_Traffic_In: in event data port ADSB_Types::TrafficReport.impl {Acceptable_Array_Size => (0 .. 150);};
			Request_In: in event data port DTU_Types::Request_Message.impl;
			Response_In: in event data port DTU_Types::Response_Message.impl;
			
			ADSB_Heartbeat_Out: out event data port ADSB_Types::HeartBeat_Message.impl;
			ADSB_Ownship_Out: out event data port ADSB_Types::TrafficReport.impl;
			ADSB_Traffic_Out: out event data port ADSB_Types::TrafficReport.impl {Acceptable_Array_Size => (0 .. 150);};
			Request_Out: out event data port DTU_Types::Request_Message.impl;
			Response_Out: out event data port DTU_Types::Response_Message.impl;
			
			Suspect_Traffic_Out: out event data port ADSB_Types::MonitorReport.impl;	
			Attestation_Response: in event data port Attestation_Response_Message.impl;
			Attestation_Request: out event data port Attestation_Request_Message.impl;
	end VPM_8600B_Ext;

	system implementation VPM_8600B_Ext.impl extends LRUs::VPM_8600B.impl
		subcomponents
			NAND_Flash: memory Memories::Flash_Memory;
			Memory_Bus: bus Memories::Memory_Bus;
			
			Proxy_Low: process CASE_Proxies::Proxy_Low.impl;
			Proxy_High: process CASE_Proxies::Proxy_High.impl;
			
			SW: process SW.impl;
			
		connections			
			A1_Basecard_mem: bus access A1_Basecard.Memory_Access <-> Memory_Bus;
			A1_Mez_mem: bus access A1_Mezz.Memory_Access <-> Memory_Bus;
			A2_Basecard_mem: bus access A2_Basecard.Memory_Access <-> Memory_Bus;
			A2_Mez_mem: bus access A2_Mezz.Memory_Access <-> Memory_Bus;
			A3_Basecard_mem: bus access A3_Basecard.Memory_Access <-> Memory_Bus;
			mem_card: bus access NAND_Flash.Flash_Data_Bus <-> Memory_Bus;
			
			A1_Basecard_Eth: bus access A1_Basecard.Eth_Conn <-> Eth_Conn;
			A1_Mez_Eth: bus access A1_Mezz.Eth_Conn <-> Eth_Conn;
			A2_Basecard_Eth: bus access A2_Basecard.Eth_Conn <-> Eth_Conn;
			A2_Mez_Eth: bus access A2_Mezz.Eth_Conn <-> Eth_Conn;
			A3_Basecard_Eth: bus access A3_Basecard.Eth_Conn <-> Eth_Conn;
			
			c1: port ADSB_Heartbeat_In -> Proxy_High.ADSB_Heartbeat_In;
			c2: port ADSB_Ownship_In -> Proxy_High.ADSB_Ownship_In;
			c3: port ADSB_Traffic_In -> Proxy_High.ADSB_Traffic_In;
			c4: port Request_In -> Proxy_Low.Request_In;
			c5: port Response_In -> Proxy_High.Response_In;
			c6: port Attestation_Response -> Proxy_Low.Attestation_Response;
			
			c7: port Proxy_High.SHM_Queue_Out -> SW.SHM_Queue_In;
			c8: port Proxy_Low.SHM_Queue_Out -> SW.SHM_Queue_In;
			c9: port SW.SHM_Queue_Out -> Proxy_High.SHM_Queue_In;
			c10: port SW.SHM_Queue_Out -> Proxy_Low.SHM_Queue_In;
			
			c11: port Proxy_Low.ADSB_Heartbeat_Out -> ADSB_Heartbeat_Out;
			c12: port Proxy_Low.ADSB_Ownship_Out -> ADSB_Ownship_Out;
			c13: port Proxy_Low.ADSB_Traffic_Out -> ADSB_Traffic_Out;
			c14: port Proxy_High.Request_Out -> Request_Out;
			c15: port Proxy_Low.Response_Out -> Response_Out;
			c16: port Proxy_Low.Suspect_Traffic_Out -> Suspect_Traffic_Out;
			c17: port Proxy_Low.Attestation_Request -> Attestation_Request;
		properties
			Actual_Memory_Binding => (
				reference (NAND_Flash)) applies to A1_Basecard.application_proc, A1_Mezz.application_proc, 
					A2_Basecard.application_proc, A2_Mezz.application_proc, A3_Basecard.application_proc;
			
			-- proxies running on separate R5 cores
			Actual_Processor_Binding => (reference(A1_Basecard.real_time_proc.Core0)) applies to Proxy_Low;
			
			Actual_Processor_Binding => (reference(A1_Basecard.real_time_proc.Core1)) applies to Proxy_High;
			
			-- new process runs on A53
			Actual_Processor_Binding => (reference(A1_Basecard.application_proc.Core0)) applies to SW;
			
		annex resolute {**
			check(HAMR_Guidelines)
		**};
						
	end VPM_8600B_Ext.impl;
	
end VPM;