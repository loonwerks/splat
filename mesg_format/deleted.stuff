fun resolve_lvals Decls path (contig,lvalSet) =
 case contig
  of Basic _ => (contig,Redblackset.add(lvalSet,path))
   | Declared s => resolve_lvals Decls path (assoc s Decls,lvalSet)
   | Recd fields =>
     let fun fieldFn (fName,c) (fields,lvset) =
            let val path' = RecdProj(path,fName)
                val (c',lvset') = resolve_lvals Decls path' (c,lvset)
            in ((fName,c')::fields,lvset')
            end
         val (rfields',lvset') = rev_itlist fieldFn fields ([],lvalSet)
     in
        (Recd(rev rfields'),lvset')
     end
   | Array (c,e) =>
     let val e' = resolve_exp_lvals lvalSet path e
         val (c', lvset') = resolve_lvals Decls path (c,lvset)
     in (Array (c',e'),lvset')
   | Union choices =>
       Union (map (resolve_exp_lvals E path##resolve_lvals E path) choices)

---------------------------------------------------------------------------

         let open Regexp_Numerics
                 val segval = IntInf.toInt(string2iint Unsigned dir segment)
             in SOME(segs@[(segment,segval)],rst,
                     Redblackmap.insert(WidthValMap,path,segval))
             end
       end

---------------------------------------------------------------------------

fun interval_of path bexp =
 case bexp
  of Beq (e,intLit n) => if is_usable path e then SOME(n,n) else NONE
   | Beq (intLit n,e) => if is_usable path e then SOME(n,n) else NONE
   | Blt (e,intLit n) =>
      if is_usable path e andalso 0 < n then
        SOME(0,n-1)
      else NONE
   | Ble (e,intLit n) =>
      if is_usable path e andalso 0 <= n then
        SOME(0,n)
      else NONE
   | Band(Ble(e1,e2),Ble(e3,e4)) =>
      if is_usable path e2 andalso e2=e3 then
       dest_endpoints(e1,e4)
      else NONE
   | otherwise => NONE
;
 case bexp
  of Beq (e,intLit n) => if is_usable path e then SOME(n,n) else NONE
   | Beq (intLit n,e) => if is_usable path e then SOME(n,n) else NONE
   | Blt (e,intLit n) =>
      if is_usable path e andalso 0 < n then
        SOME(0,n-1)
      else NONE
   | Ble (e,intLit n) =>
      if is_usable path e andalso 0 <= n then
        SOME(0,n)
      else NONE
   | Band(Ble(e1,e2),Ble(e3,e4)) =>
      if is_usable path e2 andalso e2=e3 then
       dest_endpoints(e1,e4)
      else NONE
   | otherwise => NONE
;

fun repFn a i =
 let val u2string = Regexp_Numerics.iint2string
                        Regexp_Numerics.Unsigned Regexp_Numerics.MSB
     val i2string = Regexp_Numerics.iint2string
                        Regexp_Numerics.Twos_comp Regexp_Numerics.MSB
 in case a
  of Bool => u2string 1 (LargeInt.fromInt i)
   | Char => u2string 1 (LargeInt.fromInt i)
   | Enum s => u2string 1 (LargeInt.fromInt i)
   | Signed w => i2string w (LargeInt.fromInt i)
   | Unsigned w => u2string w (LargeInt.fromInt i)
   | Float => raise ERR "repFn" "Float"
   | Double => raise ERR "repFn" "Double"
   | Blob => raise ERR "repFn" "Blob"
   | Scanned => Int.toString i  (* this is probably unnecessary *)
 end
;

(*---------------------------------------------------------------------------*)
(* Parsing. The data in this example is extremely simple; it is not worth it *)
(* to apply the contig-type machinery. Therefore we hand-roll byte buffer    *)
(* parsing.                                                                  *)
(*---------------------------------------------------------------------------*)

fun uvalueFn s =  (* make an unsigned number (MSB) from ASCII string *)
 let open Regexp_Numerics
 in IntInf.toInt(string2iint Unsigned MSB s)
 end

fun ivalueFn s =  (* make a signed number (2scomp, MSB) *)
 let open Regexp_Numerics
 in IntInf.toInt(string2iint Twos_comp MSB s)
 end

fun charAt bytes j =
  Char.chr (Word8.toInt (Word8Vector.sub(bytes,j)))

fun read_u16 bytes i =  (* read a u16 value starting at index i in bytes *)
 if i+2 <= Word8Vector.length bytes then
   uvalueFn (String.implode(List.map (charAt bytes) [i,i+1]))
 else
    raise ERR "read_u16" "";

fun read_i32 bytes (i:int) = (* read an i32 value starting at index i *)
 if i+4 <= Word8Vector.length bytes then
     ivalueFn (String.implode(List.map (charAt bytes) [i,i+1,i+2,i+3]))
 else
     raise ERR "read_i32" "";

fun read_waypoint bytes i =  (* (i32)^3 -> waypoint *)
  if i+12 <= Word8Vector.length bytes then
     {latitude =  read_i32 bytes i,
      longitude = read_i32 bytes (i+4),
      altitude =  read_i32 bytes (i+8)}
   else
       raise ERR "read_waypoint" "";

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

fun parse_uxas_polygon string =
 let fun contents_of ptree =
       (case ptree
         of RECD [("present", _), ("contents", RECD elts)] => elts
          | otherwise => raise ERR "contents_of" "")
      fun mesgs_of alist = map snd (filter (equal "mesg" o fst) alist)
 in
   case parseFn uxasEnv (VarName"root") Polygon ([],string,empty_lvalMap)
    of NONE => NONE
     | SOME ([ptree],remaining,theta) =>
         (case ptree
           of RECD [("BoundaryPointsList",
                    RECD[("len", _), ("elts", ARRAY recds)])] =>
                    let val contents = List.concat (map contents_of recds)
                        val mesgs = mesgs_of contents
                    in SOME (Array.fromList (map mk_location3D mesgs))
                    end
            | otherwise => NONE)
     | otherwise => NONE
 end;

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

(*---------------------------------------------------------------------------*)
(* Declare input buffers as global variables.                                *)
(*---------------------------------------------------------------------------*)

val kizone = Word8Array.array API.polygonSizeBytes w8zero;
val kozone = Word8Array.array API.polygonSizeBytes w8zero;

val observed_buffer = Word8Array.array API.automation_responseAASizeBytes w8zero;

val emptybuf = Word8Array.array 0 w8zero;

fun clear buffer =
 let val len = Word8Array.length buffer
     fun zero i = Word8Array.update buffer i w8zero
     fun loop j = if j < len then (zero j; loop (j+1)) else ()
 in
    loop 0
 end;

Word8Array.substring buf 1 (Word8Array.length buf - 1)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

fun seekFrom arr x i =
 let val top = Word8Array.length arr
     fun seek j =
       if j >= top then NONE else
       if Word8Array.sub(arr,j) = x then SOME j
       else seek (j+1)
 in seek i
 end;

(*---------------------------------------------------------------------------*)
(* Parsing the header of an address-attributed message. Breaks the input     *)
(* into A$B|C|D|E|F$G, where the letters stand for arbitrary strings not     *)
(* having the delimiter that folllows, e.g. "$" or "|". Return sub-string E, *)
(* which corresponds to source-entity-ID above. NB: vertical bar attached.   *)
(*---------------------------------------------------------------------------*)

fun w8_of c = Word8.fromInt (Char.ord c);

fun scanAA arr offset =
 case seekFrom arr (w8_of #"$") offset
  of NONE => NONE
   | SOME segA =>
 case seekFrom arr (w8_of #"|") (segA+offset)
  of NONE => NONE
   | SOME segB =>
 case seekFrom arr (w8_of #"|") (segB+offset)
  of NONE => NONE
   | SOME segC =>
 case seekFrom arr (w8_of #"|") (segC+offset)
  of NONE => NONE
   | SOME segD =>
 case seekFrom arr (w8_of #"|") (segD+offset)
  of NONE => NONE
   | SOME segE =>
 case seekFrom arr (w8_of #"$") (segE+offset)
  of NONE => NONE
   | SOME segF =>
     let val baseIndex = segD+offset
         val target =
           Word8Array.tabulate(segE-segD,
                 fn i => Word8Array.sub(arr,baseIndex+i))
     in SOME(Byte.bytesToString(Word8Array.vector target))
     end
;

(*---------------------------------------------------------------------------*)
(* Drop vertical bar at end of identifier, leaving only digits, I hope.      *)
(*---------------------------------------------------------------------------*)

fun dropBar s = String.substring(s,0,String.size s - 1);

(*---------------------------------------------------------------------------*)
(* Map byte array into int option. Return a SOME if first element is non-zero*)
(* and subsequent bytes decode properly according to scanAA.                 *)
(*---------------------------------------------------------------------------*)

val w8zero = Word8.fromInt 0;
val w8one = Word8.fromInt 1;

fun getID bytes =
 if Word8Array.sub(bytes,0) = w8zero then
   NONE
 else
  case scanAA bytes 1
   of NONE => NONE
    | SOME ssID => Int.fromString (dropBar ssID)
;

(*---------------------------------------------------------------------------*)
(* Tests                                                                     *)
(*---------------------------------------------------------------------------*)

fun string_to_bytes s =
 let val arr = Word8Array.array (String.size s + 1,w8zero)
     val _ = Word8Array.update(arr,0,w8one)
     val _ = Word8Array.copyVec{src=Byte.stringToBytes s,dst=arr,di=1}
 in
    arr
 end

val test1 = (SOME 500 = getID (string_to_bytes "A$B|C|D|500|F$G"));
val test2 = (SOME 500 = getID (string_to_bytes "A$B||D|500|F$G"));
val test3 = (SOME 500 = getID (string_to_bytes "199.0.0.1$p--q--r|foo|A!D!CD|500|FRED$GHIJ"));

val _ = if test1 andalso test2 andalso test3 then
         TextIO.print "\ngetID: tests passed.\n"
        else
         TextIO.print "\ngetID: tests failed.\n"

     getID (string_to_bytes(String.concat
      ["<address>$<contentType>|<descriptor>|",
       "<source_group>|500|<source-service-ID>$<the-mesg>"]));
*)
