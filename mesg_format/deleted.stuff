fun resolve_lvals Decls path (contig,lvalSet) =
 case contig
  of Basic _ => (contig,Redblackset.add(lvalSet,path))
   | Declared s => resolve_lvals Decls path (assoc s Decls,lvalSet)
   | Recd fields =>
     let fun fieldFn (fName,c) (fields,lvset) =
            let val path' = RecdProj(path,fName)
                val (c',lvset') = resolve_lvals Decls path' (c,lvset)
            in ((fName,c')::fields,lvset')
            end
         val (rfields',lvset') = rev_itlist fieldFn fields ([],lvalSet)
     in
        (Recd(rev rfields'),lvset')
     end
   | Array (c,e) =>
     let val e' = resolve_exp_lvals lvalSet path e
         val (c', lvset') = resolve_lvals Decls path (c,lvset)
     in (Array (c',e'),lvset')
   | Union choices =>
       Union (map (resolve_exp_lvals E path##resolve_lvals E path) choices)

---------------------------------------------------------------------------

         let open Regexp_Numerics
                 val segval = IntInf.toInt(string2iint Unsigned dir segment)
             in SOME(segs@[(segment,segval)],rst,
                     Redblackmap.insert(WidthValMap,path,segval))
             end
       end

---------------------------------------------------------------------------

fun interval_of path bexp =
 case bexp
  of Beq (e,intLit n) => if is_usable path e then SOME(n,n) else NONE
   | Beq (intLit n,e) => if is_usable path e then SOME(n,n) else NONE
   | Blt (e,intLit n) =>
      if is_usable path e andalso 0 < n then
        SOME(0,n-1)
      else NONE
   | Ble (e,intLit n) =>
      if is_usable path e andalso 0 <= n then
        SOME(0,n)
      else NONE
   | Band(Ble(e1,e2),Ble(e3,e4)) =>
      if is_usable path e2 andalso e2=e3 then
       dest_endpoints(e1,e4)
      else NONE
   | otherwise => NONE
;
 case bexp
  of Beq (e,intLit n) => if is_usable path e then SOME(n,n) else NONE
   | Beq (intLit n,e) => if is_usable path e then SOME(n,n) else NONE
   | Blt (e,intLit n) =>
      if is_usable path e andalso 0 < n then
        SOME(0,n-1)
      else NONE
   | Ble (e,intLit n) =>
      if is_usable path e andalso 0 <= n then
        SOME(0,n)
      else NONE
   | Band(Ble(e1,e2),Ble(e3,e4)) =>
      if is_usable path e2 andalso e2=e3 then
       dest_endpoints(e1,e4)
      else NONE
   | otherwise => NONE
;

fun repFn a i =
 let val u2string = Regexp_Numerics.iint2string
                        Regexp_Numerics.Unsigned Regexp_Numerics.MSB
     val i2string = Regexp_Numerics.iint2string
                        Regexp_Numerics.Twos_comp Regexp_Numerics.MSB
 in case a
  of Bool => u2string 1 (LargeInt.fromInt i)
   | Char => u2string 1 (LargeInt.fromInt i)
   | Enum s => u2string 1 (LargeInt.fromInt i)
   | Signed w => i2string w (LargeInt.fromInt i)
   | Unsigned w => u2string w (LargeInt.fromInt i)
   | Float => raise ERR "repFn" "Float"
   | Double => raise ERR "repFn" "Double"
   | Blob => raise ERR "repFn" "Blob"
   | Scanned => Int.toString i  (* this is probably unnecessary *)
 end
;

(*---------------------------------------------------------------------------*)
(* Parsing. The data in this example is extremely simple; it is not worth it *)
(* to apply the contig-type machinery. Therefore we hand-roll byte buffer    *)
(* parsing.                                                                  *)
(*---------------------------------------------------------------------------*)

fun uvalueFn s =  (* make an unsigned number (MSB) from ASCII string *)
 let open Regexp_Numerics
 in IntInf.toInt(string2iint Unsigned MSB s)
 end

fun ivalueFn s =  (* make a signed number (2scomp, MSB) *)
 let open Regexp_Numerics
 in IntInf.toInt(string2iint Twos_comp MSB s)
 end

fun charAt bytes j =
  Char.chr (Word8.toInt (Word8Vector.sub(bytes,j)))

fun read_u16 bytes i =  (* read a u16 value starting at index i in bytes *)
 if i+2 <= Word8Vector.length bytes then
   uvalueFn (String.implode(List.map (charAt bytes) [i,i+1]))
 else
    raise ERR "read_u16" "";

fun read_i32 bytes (i:int) = (* read an i32 value starting at index i *)
 if i+4 <= Word8Vector.length bytes then
     ivalueFn (String.implode(List.map (charAt bytes) [i,i+1,i+2,i+3]))
 else
     raise ERR "read_i32" "";

fun read_waypoint bytes i =  (* (i32)^3 -> waypoint *)
  if i+12 <= Word8Vector.length bytes then
     {latitude =  read_i32 bytes i,
      longitude = read_i32 bytes (i+4),
      altitude =  read_i32 bytes (i+8)}
   else
       raise ERR "read_waypoint" "";
