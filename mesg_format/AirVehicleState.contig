use "contig.sml";
use "uxas-constants.contig";

(*---------------------------------------------------------------------------*)
(* Set up the environment.                                                   *)
(*---------------------------------------------------------------------------*)

fun valueFn s =
 let open Regexp_Numerics
 in IntInf.toInt(string2iint Unsigned MSB s)
 end

val real32 = Basic Float;
val real64 = Basic Double;

val EMPTY = Recd [];

fun add_contig_decl E (s,d) =
 let val (Consts,Decls,aW,vFn) = E
 in (Consts,(s,d)::Decls,aW,vFn)
 end

(*---------------------------------------------------------------------------*)
(* Wrapper for a contig, with message type specified                         *)
(*---------------------------------------------------------------------------*)

fun lmcpObject mesgtyName contig = Recd [
 ("hasContents", Basic Bool),
 ("contents",
   Union [
     (Bnot(BLoc (VarName "hasContents")), EMPTY),
     (BLoc (VarName "hasContents"),
          Recd[("seriesID", i64),
               ("mesgType", u32),
               ("version",  u16),
               ("check-mesg-numbers",
                Assert (Band(Beq(Loc(VarName "seriesID"),ConstName "CMASISeriesID"),
                        Band(Beq(Loc(VarName "mesgType"),ConstName mesgtyName),
                             Beq(Loc(VarName "seriesID"),ConstName "CMASISeriesVersion"))))),
               ("payload",  contig)])
   ])
 ];

fun uxasArray contig = Recd [
  ("len", u16),
  ("elts", Array(contig, Loc (VarName"len")))
 ];


(*---------------------------------------------------------------------------*)
(* Some enumerated types                                                     *)
(*---------------------------------------------------------------------------*)

val altitude_type =
 ("AltitudeType",
  [("AGL",0),
   ("MSL",1)
  ]);

val navigation_mode =
 ("NavigationMode",
  [("Waypoint",      0),
   ("Loiter",        1),
   ("FlightDirector",2),
   ("TargetTrack",   3),
   ("FollowLeader",  4),
   ("LostComm",      5)
  ]);

val AltitudeType = Declared "AltitudeType";
val NavigationMode = Declared "NavigationMode";

(*---------------------------------------------------------------------------*)
(* Some reusable contig types                                                *)
(*---------------------------------------------------------------------------*)

val StringRecd = uxasArray (Basic Char);

val String = Declared "StringRecd";

val KeyValuePairRecd =  (* pairs of varying length strings *)
  Recd [("key",   String),
        ("value", String)];

val KeyValuePair = Declared "KeyValuePair";

val KeyValuePairObj = lmcpObject "KEYVALUEPAIR" KeyValuePair;

(*---------------------------------------------------------------------------*)
(* Set up the environment by adding enumerated types and re-usable types.    *)
(*---------------------------------------------------------------------------*)

val E = (uxas_constants_map,[],atomic_widths,valueFn)
     |> C add_enum_decl altitude_type
     |> C add_enum_decl navigation_mode
     |> C add_contig_decl ("String",StringRecd)
     |> C add_contig_decl ("KeyValuePair", KeyValuePairRecd)
;

(*---------------------------------------------------------------------------*)
(* The AirVehicleState message format as a contig type                       *)
(*---------------------------------------------------------------------------*)

val PayloadState = Recd [
 ("PayloadID",     i64),
 ("Parameters",    uxasArray KeyValuePairObj),
 ("check-max-parameters",
   Assert (Bleq(Loc(RecdProj(VarName "Parameters","len")), intLit 8)))
];

val Location3D = Recd [
  ("Latitude",  real64),
  ("Longitude", real64),
  ("Altitude",  real32),
  ("AltitudeType", AltitudeType)
];

val EntityState = Recd [
  (* A unique ID for this entity. IDs should be greater than zero *)
  ("ID", i64),

  (* Velocity in the body x-direction (positive out nose). Units="meter/sec" *)
  ("u", real32),

  (* Velocity in the body y-direction (positive out right wing). Units="meter/sec" *)
  ("v", real32),

  (* Velocity in the body z-direction (positve downward). Units="meter/sec" *)
  ("w", real32),

  (* Acceleration in the body x-direction (postive out nose). Units="meter/sec/sec" *)
  ("udot", real32),

  (* Acceleration in the body y-direction (positive out right wing).
     Units="meter/sec/sec"  *)
  ("vdot", real32),

  (* Acceleration in the body z-direction (positve downward). Units="meter/sec/sec" *)
  ("wdot",real32),

  (* Angle between true North and the projection of the body x-axis in the
     North-East plane. Units="degree" *)
  ("Heading",real32),

  (* Pitch of vehicle around body y-axis (positive upwards). Units="degree" *)
  ("Pitch",real32),

  (* Roll angle of the vehicle around body x-axis (positive right wing down).
     Units="degree" *)
  ("Roll",real32),

  (* roll-rate of vehicle (angular velocity around body x-axis).
     Positive right-wing down. Units="degree/sec" *)
  ("p",real32),

  (* pitch rate of the vehicle (angular velocity around body y-axis).
     Positive nose-up.  Units="degree/sec" *)
  ("q",real32),

  (* yaw rate of the vehicle (angular velocity around body z-axis).
       Positive nose right.  Units="degree/sec" *)
  ("r",real32),

  (* Course/Groundtrack angle of the entity referenced to true North.
     Units="degrees" *)
  ("Course",real32),

  (* Current entity ground speed.  Units="meters/second" *)
  ("Groundspeed",real32),

  (* The perceived entity location. A valid EntityState must include Location.
     (null not allowed) *)
  ("Location", lmcpObject "LOCATION3D" Location3D),

  (* The available energy remaining, expressed in terms of the percentage
       of maximum capacity.  Units="%" *)
  ("EnergyAvailable",real32),

  (* The consumption rate of available energy, expressed in terms of
       the percentage of maximum capacity used per second. Units="%/sec" *)
  ("ActualEnergyRate", real32),

  (* A list of states for any onboard payloads *)
  ("PayloadStateList", uxasArray(lmcpObject "PAYLOADSTATE" PayloadState)),
  ("check-payload-state-list-size",
   Assert (Bleq(Loc(RecdProj(VarName "PayloadStateList","len")), intLit 8))),

  (* The ID of the current waypoint. Only valid if the vehicle is in
     waypoint following mode. *)
  ("CurrentWaypoint",i64),

  (* Current command (VehicleActionCommand or MissionCommand) being executed.
       A value of zero denotes no command being executed, or that a command
       without an set identifier (CommandID) is being executed. *)
  ("CurrentCommand",i64),

  (* The current mode for this vehicle. *)
  ("Mode", NavigationMode),

  (* Tasks that this entity is currently executing.  An empty list indicates
     no associated tasks.  The task number should coincide with the task number
     in the task request.  For instance, if a waypoint is associated with a
     search task, then the task number associated with that search should be
     included in this list. *)
  ("AssociatedTasks", uxasArray i64),

  (* time stamp of this data. Time datum is defined by the application, but
     unless otherwise specified is milliseconds since 1 Jan 1970 *)
  ("Time",i64),

  (* A list that maps keys to values for the inclusion of extra, custom
     information about this entity *)
  ("Info", uxasArray(lmcpObject "KEYVALUEPAIR" KeyValuePair)),
  ("check-info-size",
   Assert (Bleq(Loc(RecdProj(VarName "Info","len")), intLit 32)))
];

val E1 = add_contig_decl E ("EntityState",EntityState);

(*---------------------------------------------------------------------------*)
(*
   Provides basic information regarding the vehicle state with regard to its
   location and orientation in the world, and current velocity in body axis.

   Provides basic state information regarding entity position, orientation,
   velocity, and acceleration. The entity body right-hand coordinate system is
   used, where X is out the nose, Y is out the right side, and Z is downward.
   The order of rotation from inertial to body coordinates is yaw-pitch-roll.

   The direction cosine matrix (DCM) for conversion from body to inertial
   coordinates is:

        [cTheta*cPsi, cTheta*sPsi, -sTheta]
        [sPhi*sTheta*cPsi-cPhi*sPsi, sPhi*sTheta*sPsi+cPhi*cPsi, sPhi*cTheta]
        [cPhi*sTheta*cPsi+sPhi*sPsi, cPhi*sTheta*sPsi-sPhi*cPsi, cPhi*cTheta]

   where c denotes cosine and s denotes sine.

   To convert from body to inertial velocities, use

      [North Vel, East Vel, Down Vel]' = DCM' * [Vx, Vy, Vz]'

   where [Vx, Vy, Vz] is the body vel or accel.
 ---------------------------------------------------------------------------*)

val AirVehicleStateRecd = Recd [
  ("EntityState",   Declared "EntityState"),
  ("Airspeed",      real32),
  ("VerticalSpeed", real32),
  ("WindSpeed",     real32),
  ("WindDirection", real32)
];

val chopper = segments E1 AirVehicleStateRecd;


(* Pretty printed version

> EntityState;
val it =
   {ID : i64
    u : Float
    v : Float
    w : Float
    udot : Float
    vdot : Float
    wdot : Float
    Heading : Float
    Pitch : Float
    Roll : Float
    p : Float
    q : Float
    r : Float
    Course : Float
    Groundspeed : Float
    Location :
     {hasContents : Bool
      contents :
       Union {
         (not(hasContents) --> {})
         (hasContents -->
           {seriesID : i64
            mesgType : u32
            version : u16
            check-mesg-numbers :
             Assert(((seriesID = CMASISeriesID) and
                    ((mesgType = Location3D) and
                     (seriesID = CMASISeriesVersion))))
            payload :
             {Latitude : Double
              Longitude : Double
              Altitude : Float
              AltitudeType : AltitudeType
              }
            })
         }
      }
    EnergyAvailable : Float
    ActualEnergyRate : Float
    PayloadStateList :
     {len : u16
      elts :
       {hasContents : Bool
        contents :
         Union {
           (not(hasContents) --> {})
           (hasContents -->
             {seriesID : i64
              mesgType : u32
              version : u16
              check-mesg-numbers :
               Assert(((seriesID = CMASISeriesID) and
                      ((mesgType = PayloadState) and
                       (seriesID = CMASISeriesVersion))))
              payload :
               {PayloadID : i64
                Parameters :
                 {len : u16
                  elts :
                   {hasContents : Bool
                    contents :
                     Union {
                      (not(hasContents) --> {})
                      (hasContents -->
                         {seriesID : i64
                          mesgType : u32
                          version : u16
                          check-mesg-numbers :
                          Assert(((seriesID = CMASISeriesID) and
                                 ((mesgType = KeyValuePair) and
                                  (seriesID = CMASISeriesVersion))))
                          payload : KeyValuePair
                            })
                         }
                      } [len]
                   }
                check-max-parameters : Assert((Parameters.len <= 8))
                }
               })
            }
         } [len]
      }
    check-payload-state-list-size : Assert((PayloadStateList.len <= 8))
    CurrentWaypoint : i64
    CurrentCommand : i64
    Mode : NavigationMode
    AssociatedTasks :
     {len : u16
      elts : i64 [len]
      }
    Time : i64
    Info :
     {len : u16
      elts :
       {hasContents : Bool
        contents :
          Union {
            (not(hasContents) --> {})
            (hasContents -->
              {seriesID : i64
               mesgType : u32
               version : u16
               check-mesg-numbers :
                Assert(((seriesID = CMASISeriesID) and
                       ((mesgType = KeyValuePair) and
                        (seriesID = CMASISeriesVersion))))
               payload : KeyValuePair
               })
            }
         } [len]
      }
    check-info-size : Assert((Info.len <= 32))
    }: contig

*)
