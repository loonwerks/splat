(*---------------------------------------------------------------------------*)
(* uxAS constants                                                            *)
(*---------------------------------------------------------------------------*)

val uxasCMASISeriesID = 4849604199710720000;
val uxasCMASISeriesVersion = 3;

(*---------------------------------------------------------------------------*)
(* uxAS message types                                                        *)
(*---------------------------------------------------------------------------*)

val uxasABSTRACTGEOMETRY = 1
val uxasKEYVALUEPAIR = 2
val uxasLOCATION3D = 3
val uxasPAYLOADACTION = 4
val uxasPAYLOADCONFIGURATION = 5
val uxasPAYLOADSTATE = 6
val uxasVEHICLEACTION = 7
val uxasTASK = 8
val uxasSEARCHTASK = 9
val uxasABSTRACTZONE = 10
val uxasENTITYCONFIGURATION = 11
val uxasFLIGHTPROFILE = 12
val uxasAIRVEHICLECONFIGURATION = 13
val uxasENTITYSTATE = 14
val uxasAIRVEHICLESTATE = 15
val uxasWEDGE = 16
val uxasAREASEARCHTASK = 17
val uxasCAMERAACTION = 18
val uxasCAMERACONFIGURATION = 19
val uxasGIMBALLEDPAYLOADSTATE = 20
val uxasCAMERASTATE = 21
val uxasCIRCLE = 22
val uxasGIMBALANGLEACTION = 23
val uxasGIMBALCONFIGURATION = 24
val uxasGIMBALSCANACTION = 25
val uxasGIMBALSTAREACTION = 26
val uxasGIMBALSTATE = 27
val uxasGOTOWAYPOINTACTION = 28
val uxasKEEPINZONE = 29
val uxasKEEPOUTZONE = 30
val uxasLINESEARCHTASK = 31
val uxasNAVIGATIONACTION = 32
val uxasLOITERACTION = 33
val uxasLOITERTASK = 34
val uxasWAYPOINT = 35
val uxasMISSIONCOMMAND = 36
val uxasMUSTFLYTASK = 37
val uxasOPERATORSIGNAL = 38
val uxasOPERATINGREGION = 39
val uxasAUTOMATIONREQUEST = 40
val uxasPOINTSEARCHTASK = 41
val uxasPOLYGON = 42
val uxasRECTANGLE = 43
val uxasREMOVETASKS = 44
val uxasSERVICESTATUS = 45
val uxasSESSIONSTATUS = 46
val uxasVEHICLEACTIONCOMMAND = 47
val uxasVIDEOSTREAMACTION = 48
val uxasVIDEOSTREAMCONFIGURATION = 49
val uxasVIDEOSTREAMSTATE = 50
val uxasAUTOMATIONRESPONSE = 51
val uxasREMOVEZONES = 52
val uxasREMOVEENTITIES = 53
val uxasFLIGHTDIRECTORACTION = 54
val uxasWEATHERREPORT = 55
val uxasFOLLOWPATHCOMMAND = 56
val uxasPATHWAYPOINT = 57
val uxasSTOPMOVEMENTACTION = 58
val uxasWAYPOINTTRANSFER = 59
val uxasPAYLOADSTOWACTION = 60
;

val uxas_constants_map =
[("CMASISeriesID",uxasCMASISeriesID),
 ("CMASISeriesVersion",uxasCMASISeriesVersion),
 ("ABSTRACTGEOMETRY",uxasABSTRACTGEOMETRY),
 ("KEYVALUEPAIR",uxasKEYVALUEPAIR),
 ("LOCATION3D",uxasLOCATION3D),
 ("PAYLOADACTION",uxasPAYLOADACTION),
 ("PAYLOADCONFIGURATION",uxasPAYLOADCONFIGURATION),
 ("PAYLOADSTATE",uxasPAYLOADSTATE),
 ("VEHICLEACTION",uxasVEHICLEACTION),
 ("TASK",uxasTASK),
 ("SEARCHTASK",uxasSEARCHTASK),
 ("ABSTRACTZONE",uxasABSTRACTZONE),
 ("ENTITYCONFIGURATION",uxasENTITYCONFIGURATION),
 ("FLIGHTPROFILE",uxasFLIGHTPROFILE),
 ("AIRVEHICLECONFIGURATION",uxasAIRVEHICLECONFIGURATION),
 ("ENTITYSTATE",uxasENTITYSTATE),
 ("AIRVEHICLESTATE",uxasAIRVEHICLESTATE),
 ("WEDGE",uxasWEDGE),
 ("AREASEARCHTASK",uxasAREASEARCHTASK),
 ("CAMERAACTION",uxasCAMERAACTION),
 ("CAMERACONFIGURATION",uxasCAMERACONFIGURATION),
 ("GIMBALLEDPAYLOADSTATE",uxasGIMBALLEDPAYLOADSTATE),
 ("CAMERASTATE",uxasCAMERASTATE),
 ("CIRCLE",uxasCIRCLE),
 ("GIMBALANGLEACTION",uxasGIMBALANGLEACTION),
 ("GIMBALCONFIGURATION",uxasGIMBALCONFIGURATION),
 ("GIMBALSCANACTION",uxasGIMBALSCANACTION),
 ("GIMBALSTAREACTION",uxasGIMBALSTAREACTION),
 ("GIMBALSTATE",uxasGIMBALSTATE),
 ("GOTOWAYPOINTACTION",uxasGOTOWAYPOINTACTION),
 ("KEEPINZONE",uxasKEEPINZONE),
 ("KEEPOUTZONE",uxasKEEPOUTZONE),
 ("LINESEARCHTASK",uxasLINESEARCHTASK),
 ("NAVIGATIONACTION",uxasNAVIGATIONACTION),
 ("LOITERACTION",uxasLOITERACTION),
 ("LOITERTASK",uxasLOITERTASK),
 ("WAYPOINT",uxasWAYPOINT),
 ("MISSIONCOMMAND",uxasMISSIONCOMMAND),
 ("MUSTFLYTASK",uxasMUSTFLYTASK),
 ("OPERATORSIGNAL",uxasOPERATORSIGNAL),
 ("OPERATINGREGION",uxasOPERATINGREGION),
 ("AUTOMATIONREQUEST",uxasAUTOMATIONREQUEST),
 ("POINTSEARCHTASK",uxasPOINTSEARCHTASK),
 ("POLYGON",uxasPOLYGON),
 ("RECTANGLE",uxasRECTANGLE),
 ("REMOVETASKS",uxasREMOVETASKS),
 ("SERVICESTATUS",uxasSERVICESTATUS),
 ("SESSIONSTATUS",uxasSESSIONSTATUS),
 ("VEHICLEACTIONCOMMAND",uxasVEHICLEACTIONCOMMAND),
 ("VIDEOSTREAMACTION",uxasVIDEOSTREAMACTION),
 ("VIDEOSTREAMCONFIGURATION",uxasVIDEOSTREAMCONFIGURATION),
 ("VIDEOSTREAMSTATE",uxasVIDEOSTREAMSTATE),
 ("AUTOMATIONRESPONSE",uxasAUTOMATIONRESPONSE),
 ("REMOVEZONES",uxasREMOVEZONES),
 ("REMOVEENTITIES",uxasREMOVEENTITIES),
 ("FLIGHTDIRECTORACTION",uxasFLIGHTDIRECTORACTION),
 ("WEATHERREPORT",uxasWEATHERREPORT),
 ("FOLLOWPATHCOMMAND",uxasFOLLOWPATHCOMMAND),
 ("PATHWAYPOINT",uxasPATHWAYPOINT),
 ("STOPMOVEMENTACTION",uxasSTOPMOVEMENTACTION),
 ("WAYPOINTTRANSFER",uxasWAYPOINTTRANSFER),
 ("PAYLOADSTOWACTION",uxasPAYLOADSTOWACTION)
];

fun bounded c interval = Recd [
  ("val", c),
  ("check", Assert (Interval "val" interval))
 ];

fun enumList elts = List.zip (elts, upto 0 (List.length elts - 1));

(*---------------------------------------------------------------------------*)
(* Arrays in uxAS are preceded by a length field.                            *)
(*---------------------------------------------------------------------------*)

fun uxasArray contig = Recd [
  ("len", u16),
  ("elts", Array contig (Loc (VarName"len")))
 ];

(*---------------------------------------------------------------------------*)
(* Enforce a given bound on array size                                       *)
(*---------------------------------------------------------------------------*)

fun uxasBoundedArray contig bound = Recd [
  ("len", u16),
  ("len-check",  Assert (Ble (Loc(VarName "len")) (IntLit bound)))
  ("elts", Array contig (Loc (VarName"len")))
 ];

(*---------------------------------------------------------------------------*)
(* Option type                                                               *)
(*---------------------------------------------------------------------------*)

fun Option contig = Recd
 [("present", Basic Bool),
  ("contents", Union [
     (BLoc (VarName "present"), contig),
     (Bnot(BLoc (VarName "present")), contig_skip)
     ])
 ];

(*---------------------------------------------------------------------------*)
(* Wrapper for a contig, with message type specified. Notice that we only    *)
(* check the message type. A more stringent check would also check the       *)
(* seriesID and seriesVersion, as follows.                                   *)
(*                                                                           *)
(*  ("check-mesg-numbers", Assert                                            *)
(*   (Band(Beq(Loc(VarName "seriesID"),ConstName "CMASISeriesID"),           *)
(*    Band(Beq(Loc(VarName "mesgType"),ConstName mesgtyName),                *)
(*         Beq(Loc(VarName "seriesVersion"),ConstName "CMASISeriesVersion")) *)
(*---------------------------------------------------------------------------*)

fun uxasMesg mesgtyName contig = Recd [
   ("seriesID", i64),
   ("mesgType", u32),
   ("check-mesg-type",
    Assert (Beq (Loc(VarName "mesgType")) (ConstName mesgtyName))),
   ("seriesVersion",  u16),
   ("mesg",  contig)
 ];

fun mesgOption name = Option o uxasMesg name;

(*---------------------------------------------------------------------------*)
(* uxAS strings. The short version is good for random message generation.    *)
(*---------------------------------------------------------------------------*)

val FullString = uxasArray (Basic Char);

val ShortString = uxasBoundedArray (Basic Char) 26;

(*---------------------------------------------------------------------------*)
(* The following gives a layer of indirection: by changing the "String"      *)
(* binding in the Decls part of the environment, all mentions of String will *)
(* resolve to the new binding. An example of where this is useful is in mesg *)
(* generation, where a random String would in general be so big that it      *)
(* would be clumsy to deal with. In that case, we can change the binding of  *)
(* String in Decls to ShortString and then all String mentions will be to    *)
(* short strings, and then a randomly generated string field would be <= 26  *)
(* in length.                                                                *)
(*---------------------------------------------------------------------------*)


val String = Declared "String";

(*---------------------------------------------------------------------------*)
(* pairs of strings                                                          *)
(*---------------------------------------------------------------------------*)

val KeyValuePair =  (* pairs of varying length strings *)
  Recd [("key",   String),
        ("value", String)];

(*---------------------------------------------------------------------------*)
(* Enumerations                                                              *)
(*---------------------------------------------------------------------------*)

val altitude_type = ("AltitudeType", enumList ["AGL","MSL"]);
val speed_type    = ("SpeedType",    enumList ["AirSpeed","GroundSpeed"]);
val turn_type     = ("TurnType",     enumList ["TurnShort", "FlyOver"]);

val wavelength_band =
 ("WavelengthBand", enumList ["AllAny","EO","LWIR","SWIR","MWIR","Other"]);

val navigation_mode =
 ("NavigationMode",
  enumList ["Waypoint", "Loiter", "FlightDirector",
            "TargetTrack", "FollowLeader", "LostComm"]);

val command_status_type =
 ("CommandStatusType",
  enumList ["Pending", "Approved", "InProcess", "Executed", "Cancelled"]);

val uxasAltitudeType   = Declared "AltitudeType"
val uxasWavelengthBand = Declared "WavelengthBand"
val uxasNavigationMode = Declared "NavigationMode"
val uxasSpeedType      = Declared "SpeedType"
val uxasTurnType       = Declared "TurnType"
val uxasCommandStatusType = Declared "CommandStatusType";

(*---------------------------------------------------------------------------*)
(* Basic uxAS environment plus enumerations.                                 *)
(*---------------------------------------------------------------------------*)

val uxasEnv =
  (uxas_constants_map,[],atomic_widths,uxas_valFn,dvalFn)
     |> C add_contig_decl ("String",FullString)
     |> C add_contig_decl ("KeyValuePair", KeyValuePair)
     |> C add_enum_decl altitude_type
     |> C add_enum_decl wavelength_band
     |> C add_enum_decl navigation_mode
     |> C add_enum_decl speed_type
     |> C add_enum_decl turn_type
     |> C add_enum_decl command_status_type
;

(*---------------------------------------------------------------------------*)
(* Messages                                                                  *)
(*---------------------------------------------------------------------------*)

val operating_region = Recd [
  ("ID",             i64),
  ("keep_in_areas",  uxasBoundedArray u64 32),
  ("keep_out_areas", uxasBoundedArray u64 32)
  ];

val automation_request = Recd [
  ("EntityList",        uxasBoundedArray i64 16),
  ("TaskList",          uxasBoundedArray i64 32),
  ("TaskRelationShips", String),
  ("OperatingRegion",   i64),
  ("RedoAllTasks",      Basic Bool)
  ];

val Wedge = Recd [
  ("AzimuthCenterline",  real32),
  ("VerticalCenterline", real32),
  ("AzimuthExtent",      real32),
  ("VerticalExtent",     real32)
 ];

val Location3D = Recd [
  ("Latitude",  real64),
  ("Longitude", real64),
  ("Altitude",  real32),
  ("AltitudeType", AltitudeType)
];

val Checked_Location3D = Recd [
  ("Latitude",  real64),
  ("Lat-check", Assert (
    Band(DleA(~90.0,Loc(VarName"Latitude")),
         DleB(Loc(VarName"Latitude"),90.0)))),
  ("Longitude", real64),
  ("Lon-check", Assert (
    Band(DleA(~180.0,Loc(VarName"Longitude")),
         DleB(Loc(VarName"Longitude"),180.0)))),
  ("Altitude",  real32),
  ("AltitudeType", AltitudeType),
  ("AltitudeType-check", Assert (
    Ble(Loc(VarName"AltitudeType"),intLit 1)))
];

val Location3D = Checked_Location3D;

(*---------------------------------------------------------------------------*)
(* LineSearchTask message                                                    *)
(*---------------------------------------------------------------------------*)

val linesearch_task = Recd [
  (* Task *)
  ("TaskID",           i64),
  ("Label",            String),
  ("EligibleEntities", uxasBoundedArray i64 32),
  ("RevisitRate",      real32),
  ("Parameters",       uxasBoundedArray (mesgOption "KEYVALUEPAIR" KeyValuePair) 8),
  ("Priority",         u8),
  ("Required",         Basic Bool),

  (* SearchTask *)
  ("DesiredWavelengthBands", uxasBoundedArray WavelengthBand 8),
  ("DwellTime",              i64),
  ("GroundSampleDistance",   real32),

  (* LineSearchTask *)
  ("PointList",     uxasBoundedArray (mesgOption "LOCATION3D" Location3D) 1024),
  ("ViewAngleList", uxasBoundedArray (mesgOption "WEDGE" Wedge) 16),
  ("UseInertialViewAngles", Basic Bool)
];


(*---------------------------------------------------------------------------*)
(* AutomationResponse message                                                *)
(*---------------------------------------------------------------------------*)

val VehicleAction = Recd [
  ("AssociatedTaskList", uxasBoundedArray i64 8)
];

val VehicleActionCommand = Recd [
  ("CommandID",         i64),
  ("VehicleID",         i64),
  ("VehicleActionList", uxasBoundedArray (mesgOption "VEHICLEACTION" VehicleAction) 8),
  ("Status",            CommandStatusType),
  ("check-status",      Assert (Ble(Loc(VarName"Status"),intLit 4)))
 ];

val Waypoint = Recd [
  ("Location",            Location3D),  (* Q: mesgOption this? A: Nope: extension base *)
  ("Number",              i64),
  ("NextWaypoint",        i64),
  ("Speed",               real32),
  ("SpeedType",           SpeedType),
  ("check-speed-type",    Assert (Ble(Loc(VarName"SpeedType"),intLit 1))),
  ("ClimbRate",           real32),
  ("TurnType",            TurnType),
  ("check-turn-type",     Assert (Ble(Loc(VarName"TurnType"),intLit 1))),
  ("VehicleActionList",   uxasBoundedArray (mesgOption "VEHICLEACTION" VehicleAction) 8),
  ("ContingencyWaypointA",i64),
  ("ContingencyWaypointB",i64),
  ("AssociatedTasks",     uxasBoundedArray i64 8)
 ];

val MissionCommand = Recd [
 ("VehicleActionCommand", VehicleActionCommand), (* Q: mesgOption this? Nope: extension base *)
 ("WaypointList",         uxasBoundedArray (mesgOption "WAYPOINT" Waypoint) 1024),
 ("FirstWaypoint",        i64)
];

val automation_response = Recd [
 ("MissionCommandList", uxasBoundedArray (mesgOption "MISSIONCOMMAND" MissionCommand) 16),
 ("VehicleCommandList", uxasBoundedArray (mesgOption "VEHICLEACTIONCOMMAND" VehicleActionCommand) 64),
 ("Info",               uxasBoundedArray (mesgOption "KEYVALUEPAIR" KeyValuePair) 8)
];

(*---------------------------------------------------------------------------*)
(* AirVehicleState message                                                   *)
(*---------------------------------------------------------------------------*)

val PayloadState = Recd [
 ("PayloadID",  i64),
 ("Parameters", uxasBoundedArray (mesgOption "KEYVALUEPAIR" KeyValuePair) 8)
];

val EntityState = Recd [
  ("ID",     i64),
  ("u",      real32),
  ("v",      real32),
  ("w",      real32),
  ("udot",   real32),
  ("vdot",   real32),
  ("wdot",   real32),
  ("Heading",real32),
  ("Pitch",  real32),
  ("Roll",   real32),
  ("p",      real32),
  ("q",      real32),
  ("r",      real32),
  ("Course", real32),
  ("Groundspeed",      real32),
  ("Location",         mesgOption "LOCATION3D" Location3D),
  ("EnergyAvailable",  real32),
  ("ActualEnergyRate", real32),
  ("PayloadStateList", uxasBoundedArray(mesgOption "PAYLOADSTATE" PayloadState) 8),
  ("CurrentWaypoint",  i64),
  ("CurrentCommand",   i64),
  ("Mode",             NavigationMode),
  ("AssociatedTasks",  uxasBoundedArray i64 8),
  ("Time",             i64),
  ("Info", uxasBoundedArray(mesgOption "KEYVALUEPAIR" KeyValuePair) 32)
];


val airvehicle_state = Recd [
  ("EntityState",   EntityState),
  ("Airspeed",      real32),
  ("VerticalSpeed", real32),
  ("WindSpeed",     real32),
  ("WindDirection", real32)
];

(*---------------------------------------------------------------------------*)
(* Full uxAS operating region message looks like the following               *)
(* (Eric Mercer dug this info out):                                          *)
(*                                                                           *)
(*  <address> $ <attributes> $ <mesg>                                        *)
(*                                                                           *)
(* where                                                                     *)
(*                                                                           *)
(*  <address> is e.g. uxas.project.isolate.IntruderAlert,                    *)
(*                    uxas.roadmonitor,  etc.                                *)
(*                                                                           *)
(*  <attributes> = <contentType>       ;; string of non "|" chars            *)
(*               | <descriptor>        ;; ditto                              *)
(*               | <source-group>      ;; ditto                              *)
(*               | <source-entity-ID>  ;; ditto                              *)
(*               | <source-service-ID> ;; ditto                              *)
(*                                                                           *)
(* (The vertical bars are included in the message text.)                     *)
(*                                                                           *)
(* Using some regexp-like notation, this is                                  *)
(*                                                                           *)
(*  (.* "$") (.* "|"){4} (.* "$") <mesg-object>                              *)
(*                                                                           *)
(* The mesg field is a mesgOption as above                                   *)
(*---------------------------------------------------------------------------*)

val attributes = Recd [
 ("contentType",       Scanner (scanTo "|")),
 ("descriptor",        Scanner (scanTo "|")),
 ("source_group",      Scanner (scanTo "|")),
 ("source_entity_ID",  Scanner (scanTo "|")),
 ("source_service_ID", Scanner (scanTo "$"))
 ];

fun full_mesg contig = Recd [
  ("address",      Scanner (scanTo "$")),
  ("attributes",   attributes),
  ("controlString",i32),  (* = 0x4c4d4350 = valueFn "LMCP" *)
  ("check",        Assert (Beq(Loc(VarName"controlString"),intLit 0x4c4d4350))),
  ("mesgSize",     u32),
  ("mesg",         contig),
  ("checksum",     u32)
 ];

(*---------------------------------------------------------------------------*)
(* Full messages for a few formats                                           *)
(*---------------------------------------------------------------------------*)

val fullOperatingRegionMesg =
  full_mesg (mesgOption "OPERATINGREGION" operating_region);

val fullAutomationRequestMesg =
  full_mesg (mesgOption "AUTOMATIONREQUEST" automation_request);

val fullLineSearchTaskMesg =
  full_mesg (mesgOption "LINESEARCHTASK" linesearch_task);

val fullAutomationResponseMesg =
  full_mesg (mesgOption "AUTOMATIONRESPONSE" automation_response);

val fullAirVehicleStateMesg =
  full_mesg (mesgOption "AIRVEHICLESTATE" airvehicle_state);


(*===========================================================================*)
(* Parsing. First define target datastructures.                              *)
(*===========================================================================*)

type i64 = Int.int;
type real32 = Real32.real;
type real64 = Real.real;
type KeyValPair = string * string;

(*---------------------------------------------------------------------------*)
(* Enumerations                                                              *)
(*---------------------------------------------------------------------------*)

datatype SpeedType = AirSpeed | GroundSpeed;
datatype TurnType = TurnShort | FlyOver;

datatype AltitudeType = AGL | MSL;

datatype WavelengthBand = AllAny | EO | LWIR | SWIR | MWIR | Other;

datatype NavigationMode =
	 WAYPOINT | Loiter | FlightDirector | TargetTrack | FollowLeader | LostComm;

datatype CommandStatusType = Pending | Approved | InProcess | Executed | Cancelled;

type Location3D =
     {Latitude  : real64,
      Longitude : real64,
      Altitude  : real32,
      AltitudeType : AltitudeType};

type Polygon = Location3D array

type VehicleAction = i64 array

type Waypoint =
  {Location    : Location3D,
   Number      : i64,
   NextWaypoint: i64,
   Speed       : real32,
   SpeedType   : SpeedType,
   ClimbRate   : real32,
   TurnType    : TurnType,
   VehicleActionList    : i64 array array,
   ContingencyWaypointA : i64,
   ContingencyWaypointB : i64,
   AssociatedTasks      : i64 array
 };

type VehicleActionCommand =
 {CommandID : i64,
  VehicleID : i64,
  VehicleActionList : VehicleAction array,
  Status : CommandStatusType}

type MissionCommand =
 {VehicleActionCommand : VehicleActionCommand,
  WaypointList  : Waypoint array,
  FirstWaypoint : i64};


type AutomationResponse =
     {MissionCommandList : MissionCommand array,
      VehicleCommandList : VehicleActionCommand array,
      Info : KeyValPair array}

(*---------------------------------------------------------------------------*)
(* Parsing                                                                   *)
(*---------------------------------------------------------------------------*)

val mk_i64     = uxas_valFn (Signed 8);
fun mk_float s = Real32.fromInt 42;
fun mk_double s = dvalFn Double s;

fun mk_leaf f (LEAF(_,s)) = f s
  | mk_leaf f otherwise = raise ERR "mk_leaf" ""

fun mk_bounded_array eltFn ptree =
 case ptree
  of RECD [("len",_),("elts", ARRAY elts)] => Array.fromList (List.map eltFn elts)
   | otherwise  => raise ERR "mk_bounded_array" "";

fun dest_header ptree =
 case ptree
  of RECD [("seriesID",_),
           ("mesgType",_),
           ("seriesVersion",_),
           ("mesg", pt)] => pt
   | otherwise => raise ERR "dest_header" "";

fun mk_uxasOption eltFn ptree =
 case ptree
  of RECD [("present", _), ("contents", elt)] =>
        (case elt
          of RECD [] => NONE
           | contig  => SOME(eltFn contig))
   | otherwise => raise ERR "mk_uxasOption" "";

fun mk_mesgOption eltFn = mk_uxasOption (eltFn o dest_header);

fun mk_bounded_mesgOption_array eltFn ptree =
 case ptree
  of RECD [("len",_),("elts", ARRAY elts)]
      => Array.fromList (List.mapPartial (mk_mesgOption eltFn) elts)
   | otherwise  => raise ERR "mk_bounded_mesgOption_array" "";

fun AA_mesg mesgFn ptree =
 case ptree
  of RECD [("address",_),
           ("attributes",_),
           ("controlString",_),
           ("mesgSize",_),
           ("mesg", pt),
           ("checksum",_)] => mesgFn pt
   | otherwise => raise ERR "AA_mesg" "";


fun decodeCommandStatusType s =
  let val i = uxas_valFn (Enum "CommandStatusType") s
  in if i = 0 then Pending else
     if i = 1 then Approved else
     if i = 2 then InProcess else
     if i = 3 then Executed else
     if i = 4 then Cancelled
     else raise ERR "decodeCommandStatusType" ""
  end;

fun decodeAltitudeType s =
  let val i = uxas_valFn (Enum "AltitudeType") s
  in if i = 0 then AGL else
     if i = 1 then MSL
     else raise ERR "decodeAltitudeType" ""
  end;

fun decodeSpeedType s =
  let val i = uxas_valFn (Enum "SpeedType") s
  in if i = 0 then AirSpeed else
     if i = 1 then GroundSpeed
     else raise ERR "decodeSpeedType" ""
  end;

fun decodeTurnType s =
  let val i = uxas_valFn (Enum "TurnType") s
  in if i = 0 then TurnShort else
     if i = 1 then FlyOver
     else raise ERR "decodTurnType" ""
  end;

fun mk_location3D ptree =
 case ptree
  of RECD [("Latitude", lat),
           ("Longitude", lon),
           ("Altitude",  alt),
           ("AltitudeType", alt_type)]
     => {Latitude  = mk_leaf mk_double lat,
         Longitude = mk_leaf mk_double lon,
         Altitude  = mk_leaf mk_float alt,
         AltitudeType = mk_leaf decodeAltitudeType alt_type}
   | otherwise => raise ERR "mk_location3D" "";


(*---------------------------------------------------------------------------*)
(* Geofence monitor input                                                    *)
(*---------------------------------------------------------------------------*)

val PhaseII_Polygon = Array(Location3D, intLit 2);

(*---------------------------------------------------------------------------*)
(* Decode polygon encoded with uxas encoding                                 *)
(*---------------------------------------------------------------------------*)

fun mk_phase2_polygon ptree =
  case ptree
   of ARRAY recds => Array.fromList (map mk_location3D recds)
    | otherwise => raise ERR "mk_phase2_polygon" ""

fun parse_phase2_polygon string =
  case parseFn uxasEnv (VarName"root") PhaseII_Polygon ([],string,empty_lvalMap)
   of NONE => raise ERR "parse_phase2_polygon" ""
    | SOME ([ptree],remaining,theta) => mk_phase2_polygon ptree
    | otherwise => raise ERR "parse_phase2_polygon" ""

(*---------------------------------------------------------------------------*)
(* VehicleAction =                                                           *)
(*  Recd [("AssociatedTaskList", uxasBoundedArray i64 8)]                    *)
(*---------------------------------------------------------------------------*)

fun mk_VA ptree =
 case ptree
  of RECD [("AssociatedTaskList",RECD [("len", _),("elts",ARRAY elts)])]
       => Array.fromList (map (mk_leaf mk_i64) elts)
   | otherwise  => raise ERR "mk_VA" "";

(*---------------------------------------------------------------------------*)
(* VehicleActionCommand = Recd [                                             *)
(*  ("CommandID",         i64),                                              *)
(*  ("VehicleID",         i64),                                              *)
(*  ("VehicleActionList", uxasBoundedArray                                   *)
(*                            (mesgOption "VEHICLEACTION" VehicleAction) 8), *)
(*  ("Status",            CommandStatusType)                                 *)
(* ]                                                                         *)
(*---------------------------------------------------------------------------*)

fun mk_VAC ptree : VehicleActionCommand =
 case ptree
  of RECD [("CommandID",cid),
           ("VehicleID", vid),
           ("VehicleActionList", valist),
           ("Status", status)]
      => {CommandID         = mk_leaf mk_i64 cid,
          VehicleID         = mk_leaf mk_i64 vid,
          VehicleActionList = mk_bounded_mesgOption_array mk_VA valist,
          Status            = mk_leaf decodeCommandStatusType status}
   | otherwise  => raise ERR "mk_VAC" ""

(*---------------------------------------------------------------------------*)
(* Waypoint = Recd [                                                         *)
(*  ("Location",            Location3D),                                     *)
(*  ("Number",              i64),                                            *)
(*  ("NextWaypoint",        i64),                                            *)
(*  ("Speed",               real32),                                         *)
(*  ("SpeedType",           SpeedType),                                      *)
(*  ("check-speed-type",    Assert (Ble(Loc(VarName"SpeedType"),intLit 1))), *)
(*  ("ClimbRate",           real32),                                         *)
(*  ("TurnType",            TurnType),                                       *)
(*  ("check-turn-type",     Assert (Ble(Loc(VarName"TurnType"),intLit 1))),  *)
(*  ("VehicleActionList",   uxasBoundedArray                                 *)
(*                             (mesgOption "VEHICLEACTION" VehicleAction) 8),*)
(*  ("ContingencyWaypointA",i64),                                            *)
(*  ("ContingencyWaypointB",i64),                                            *)
(*  ("AssociatedTasks",     uxasBoundedArray i64 8)                          *)
(* ]                                                                         *)
(*---------------------------------------------------------------------------*)

fun mk_Waypoint ptree : Waypoint =
  case ptree
   of RECD [("Location", loc3d), ("Number", n),
            ("NextWaypoint",     next_wpt), ("Speed", speed),
            ("SpeedType", speed_type), ("ClimbRate",climbrate),
            ("TurnType",turn_type), ("VehicleActionList", valist),
            ("ContingencyWaypointA",cwptA), ("ContingencyWaypointB",cwptB),
            ("AssociatedTasks",  atasks)]
      => {Location     = mk_location3D loc3d,
          Number       = mk_leaf mk_i64 n,
          NextWaypoint = mk_leaf mk_i64 next_wpt,
          Speed        = mk_leaf mk_float speed,
          SpeedType    = mk_leaf decodeSpeedType speed_type,
          ClimbRate    = mk_leaf mk_float climbrate,
          TurnType     = mk_leaf decodeTurnType turn_type,
          VehicleActionList    = mk_bounded_mesgOption_array mk_VA valist,
          ContingencyWaypointA = mk_leaf mk_i64 cwptA,
          ContingencyWaypointB = mk_leaf mk_i64 cwptB,
          AssociatedTasks      = mk_bounded_array (mk_leaf mk_i64) atasks}
      | otherwise => raise ERR "mk_Waypoint" ""


(*---------------------------------------------------------------------------*)
(*  MissionCommand = Recd [                                                  *)
(* ("VehicleActionCommand", VehicleActionCommand),                           *)
(* ("WaypointList",                                                          *)
(*     uxasBoundedArray(mesgOption "WAYPOINT" Waypoint) 1024),               *)
(* ("FirstWaypoint", i64)                                                    *)
(* ]                                                                         *)
(*---------------------------------------------------------------------------*)

fun mk_MC ptree : MissionCommand =
  case ptree
   of RECD [("VehicleActionCommand", vac),
            ("WaypointList", wpts),
            ("FirstWaypoint",fst_wpt)]
       => {VehicleActionCommand = mk_VAC vac,
           WaypointList = mk_bounded_mesgOption_array mk_Waypoint wpts,
           FirstWaypoint = mk_leaf mk_i64 fst_wpt}
    | otherwise => raise ERR "mk_mission_command" ""

(*---------------------------------------------------------------------------*)
(* automation_response = Recd [                                              *)
(*  ("MissionCommandList",                                                   *)
(*      uxasBoundedArray (mesgOption "MISSIONCOMMAND" MissionCommand) 16),   *)
(*  ("VehicleCommandList",                                                   *)
(*      uxasBoundedArray                                                     *)
(*           (mesgOption "VEHICLEACTIONCOMMAND" VehicleActionCommand) 64),   *)
(*  ("Info", uxasBoundedArray (mesgOption "KEYVALUEPAIR" KeyValuePair) 8)    *)
(* ]                                                                         *)
(*---------------------------------------------------------------------------*)

fun hdchar s = String.sub(s,0);

val mk_char = mk_leaf hdchar;

fun mk_string ptree =
 case ptree
  of RECD [("len",_),("elts", ARRAY elts)] => String.implode (List.map mk_char elts)
   | otherwise  => raise ERR "mk_string" "";

fun mk_KV_pair ptree =
 case ptree
  of RECD [("key", kstr), ("value", vstr)]
       => (mk_string kstr,mk_string vstr)
   | otherwise => raise ERR "mk_KV_pair" ""

fun mk_automation_response ptree : AutomationResponse =
  case ptree
   of RECD [("MissionCommandList",mclist),
            ("VehicleCommandList",vaclist),
            ("Info", infolist)]
       => {MissionCommandList = mk_bounded_mesgOption_array mk_MC mclist,
           VehicleCommandList = mk_bounded_mesgOption_array mk_VAC vaclist,
           Info = mk_bounded_mesgOption_array mk_KV_pair infolist}
    | otherwise => raise ERR "mk_automation_response" ""

fun mk_AR_event ptree : AutomationResponse option =
 case mk_uxasOption I ptree (* strip off leading "isEvent" byte *)
  of NONE => NONE
   | SOME aatree => AA_mesg (mk_mesgOption mk_automation_response) aatree;

(*---------------------------------------------------------------------------*)
(* Generate messages to test the parser on.                                  *)
(*---------------------------------------------------------------------------*)

fun scanRandFn (path:lval) = "!!UNEXPECTED!!"

fun override_decl (s,c) alist =
 case Lib.partition (equal s o fst) alist
  of ([_],list) => (s,c)::list
   | ([],list) => raise ERR "override_decl" "binding to override not found"
   | otherwise => raise ERR "override_decl" "multiple bindings to override found"
;

(*---------------------------------------------------------------------------*)
(* Put short strings into Decls. See discussion where String declared above  *)
(*---------------------------------------------------------------------------*)

val randEnv =
 let val (Consts,Decls,atomicWidths,valFn,dvalFn) = uxasEnv
     val Decls' = override_decl ("String",ShortString) Decls
 in (Consts,Decls',atomicWidths,valFn,dvalFn,
     uxas_repFn,scanRandFn,Random.newgen())
 end;

fun gen_string () =
  String.concat
    (randFn randEnv
        ([(VarName"root",String)], empty_lvalMap, []));

fun gen_kvpair () =
  String.concat
    (randFn randEnv
        ([(VarName"root",KeyValuePair)], empty_lvalMap, []));

let val (ptree,remaining,theta) = parse uxasEnv KeyValuePair (gen_kvpair())
in
  mk_KV_pair ptree
end;

fun gen_phase2_polygon () =
  String.concat
    (randFn randEnv
        ([(VarName"root",PhaseII_Polygon)], empty_lvalMap, []));

parse_phase2_polygon (gen_phase2_polygon());

fun gen_VA () =
  String.concat
    (randFn randEnv
        ([(VarName"root",VehicleAction)], empty_lvalMap, []));

let val (ptree,remaining,theta) = parse uxasEnv VehicleAction (gen_VA())
in mk_VA ptree
end;

fun gen_VAC () =
  String.concat
    (randFn randEnv
        ([(VarName"root",VehicleActionCommand)], empty_lvalMap, []));

let val (ptree,remaining,theta) = parse uxasEnv VehicleActionCommand (gen_VAC())
in mk_VAC ptree
end;

fun gen_waypoint () =
  String.concat
    (randFn randEnv
        ([(VarName"root",Waypoint)], empty_lvalMap, []));

let val (ptree,remaining,theta) = parse uxasEnv Waypoint (gen_waypoint())
in mk_Waypoint ptree
end;

fun gen_MC () =
  String.concat
    (randFn randEnv
        ([(VarName"root",MissionCommand)], empty_lvalMap, []));

let val (ptree,remaining,theta) = parse uxasEnv MissionCommand (gen_MC())
in mk_MC ptree
end;

fun gen_AResp () =
  String.concat
    (randFn randEnv
        ([(VarName"root",automation_response)], empty_lvalMap, []));
let
val (ptree,remaining,theta) = parse uxasEnv automation_response (gen_AResp())
in
  mk_automation_response ptree
end;
