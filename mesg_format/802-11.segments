(*---------------------------------------------------------------------------*)
(* Based off 802-11.bitcodec                                                 *)
(*---------------------------------------------------------------------------*)

datatype iexp
  = Val of string
  | Const of string
  | EnumName of string
  | intLit of int
  | Add of iexp * iexp
  | Mult of iexp * iexp
  | Diff of iexp * iexp

fun Eval (E as (fldEnv:string -> int,cEnv,eEnv)) e =
 case e
  of Val s       => fldEnv s
   | Const s     => cEnv s
   | Enum p      => eEnv p
   | intLit i    => i
   | Add(e1,e2)  => Eval E e1 + Eval E e2
   | Mult(e1,e2) => Eval E e1 * Eval E e2
   | Diff(e1,e2) => Eval E e1 - Eval E e2 ;

datatype segments
  = Esegs of string list
  | Cseg of (string * iexp) * segments
  | Union of iexp * (int -> segments)

(*---------------------------------------------------------------------------*)
(* @enum object Frame {                                                      *)
(*   'Management // 00                                                       *)
(*   'Control // 1                                                           *)
(*   'Data // 2                                                              *)
(*   'Reserved // 3                                                          *)
(* }                                                                         *)
(*---------------------------------------------------------------------------*)

fun Bits n = Const n;
fun Bytes n = Const (n * 8);

datatype Frame = Management | Control | Data | Reserved;

fun Frame_enc Management = 0
  | Frame_enc Control = 1
  | Frame_enc Data = 2
  | Frame_enc Reserved = 3;

fun enum_width "Frame" = 2;

val macHeader =
 Cseg (("protocol",  Bits 2),
 Cseg (("tpe",       Bits (enum_width "Frame")),
 Cseg (("subType",   Bits 4),
 Cseg (("toDS",      Bits 1),
 Cseg (("fromDS",    Bits 1),
 Cseg (("moreFrag",  Bits 1),
 Cseg (("retry",     Bits 1),
 Cseg (("powerMgmt", Bits 1),
 Cseg (("moreData",  Bits 1),
 Cseg (("wep",       Bits 1),
 Cseg (("order",     Bits 1),
 Cseg (("duration",  Bytes 2),
 Union(Val "tpe", fn i =>
  if i = Frame_enc Data then
       Cseg(("address1",   Bytes 6),
       Cseg(("address2",   Bytes 6),
       Cseg(("address3",   Bytes 6),
       Cseg(("fragNumber", Bits 4),
       Cseg(("seqNumber",  Bits 12),
       Cseg(("address4",   Bytes 6),
       Segs["protocol", "tpe", "subType", "toDS", "fromDS", "moreFrag", "retry",
            "powerMgmt", "moreData", "wep", "order", "duration",
            "address1", "address2", "address3", "fragNumber", "seqNumber", "address4"]
           ))))))
  else
  if i = Frame_enc Control
  then Union (Val "subType", fn j =>
       if j = 12 then
          Cseg(("receiver", Bytes 6),
          Segs["protocol", "tpe", "subType", "toDS","fromDS", "moreFrag",
               "retry", "powerMgmt", "moreData", "wep","order","duration","receiver"])
       else
       if j = 11 then
          Cseg(("receiver",    Bytes 6),
          Cseg(("transmitter", Bytes 6),
          Segs["protocol", "tpe", "subType", "toDS","fromDS",
               "moreFrag", "retry", "powerMgmt", "moreData", "wep",
               "order","duration","receiver","transmitter"]
              ))
       else Segs [])
  else Segs []
 )))))))))))))
;

(*---------------------------------------------------------------------------*)
(* Modelling in logic                                                        *)
(*---------------------------------------------------------------------------*)

load "numposrepTheory";

Definition Bits_def :
  Bits (n:num) = n
End;

Definition Bytes_def :
  Bytes n = n * 8
End;

Hol_datatype `Frame = Management | Control | Data | Reserved`;

Definition Frame_enc_def :
  Frame_enc Management = 0 /\
  Frame_enc Control    = 1 /\
  Frame_enc Data       = 2 /\
  Frame_enc Reserved   = 3
End

Definition Frame_width :
  Frame_width = Bits 2
End;

Definition Val_def :
 Val n = @k. k IN count (2**n)
End

Definition dec_def :
  decN list = l2n 2 list
End;

Definition Valset_def :
 Valset X = IMAGE decN X
End

Definition WIDTH_def :
 WIDTH L n <=> (LENGTH L = n)
End

val macHeader_tm =
 ``let protocol  = Bits 2 ;
       tpe       = Frame_width ;
       subType   = Bits 4 ;
       toDS      = Bits 1 ;
       fromDS    = Bits 1 ;
       moreFrag  = Bits 1 ;
       retry     = Bits 1 ;
       powerMgmt = Bits 1 ;
       moreData  = Bits 1 ;
       wep       = Bits 1 ;
       order     = Bits 1 ;
       duration  = Bytes 2 ;
   in
   if Val tpe = Frame_enc Data then
       let address1   = Bytes 6 ;
           address2   = Bytes 6 ;
           address3   = Bytes 6 ;
           fragNumber = Bits 4  ;
           seqNumber  = Bits 12 ;
           address4   = Bytes 6 ;
        in
        [ protocol ; tpe ; subType ; toDS ; fromDS ; moreFrag ; retry ;
          powerMgmt ; moreData ; wep ; order ; duration ; address1 ;
          address2 ; address3 ; fragNumber ; seqNumber ; address4 ]

  else
  if Val tpe = Frame_enc Control
  then (if Val subType = 12 then
          let receiver = Bytes 6
          in [ protocol ; tpe ; subType ; toDS ; fromDS ; moreFrag ; retry ;
               powerMgmt ; moreData ; wep ; order ; duration ; receiver ]
        else
        if Val subType = 11 then
          let receiver    = Bytes 6 ;
              transmitter = Bytes 6 ;
          in [ protocol ; tpe ; subType ; toDS ; fromDS ; moreFrag ; retry ;
               powerMgmt ; moreData ; wep ; order ; duration ; receiver ; transmitter ]
        else [])
  else []``
;

Definition macHeader_segments_def :
 macHeader_segments L <=>
   ?frameControl
    protocol tpe subType toDS fromDS moreFrag retry
    powerMgmt moreData wep order duration.
     (frameControl = protocol ++ tpe ++ subType ++
                     toDS ++ fromDS ++ moreFrag ++
                     retry ++ powerMgmt ++ moreData ++
                     wep ++ order) /\
      WIDTH protocol  (Bits 2)  /\
      WIDTH tpe    Frame_width  /\
      WIDTH subType   (Bits 4)  /\
      WIDTH toDS      (Bits 1)  /\
      WIDTH fromDS    (Bits 1)  /\
      WIDTH moreFrag  (Bits 1)  /\
      WIDTH retry     (Bits 1)  /\
      WIDTH powerMgmt (Bits 1)  /\
      WIDTH moreData  (Bits 1)  /\
      WIDTH wep       (Bits 1)  /\
      WIDTH order     (Bits 1)  /\
      WIDTH duration  (Bytes 2) /\
   if decN tpe = Frame_enc Data then
      (?address1 address2 address3 fragNumber seqNumber address4.
         WIDTH address1   (Bytes 6) /\
         WIDTH address2   (Bytes 6) /\
         WIDTH address3   (Bytes 6) /\
         WIDTH fragNumber (Bits 4)  /\
         WIDTH seqNumber  (Bits 12) /\
         WIDTH address4   (Bytes 6) /\
         L = frameControl ++ duration ++
             address1 ++ address2 ++ address3 ++
             fragNumber ++ seqNumber ++ address4)
   else
   if (decN tpe = Frame_enc Control) /\ (decN subType = 12) then
      (?receiver. WIDTH receiver (Bytes 6) /\
         L = frameControl ++ duration ++ receiver)
   else
   if (decN tpe = Frame_enc Control) /\ (decN subType = 11) then
      (?receiver transmitter.
        WIDTH receiver    (Bytes 6) /\
        WIDTH transmitter (Bytes 6) /\
        L = frameControl ++ duration ++ receiver ++ transmitter)
   else F
End;


(*---------------------------------------------------------------------------*)
(* Looking for an elegant and unambiguous syntax.                            *)
(*---------------------------------------------------------------------------*)
(*
macHeader =
   let frameControl =
         [protocol  : Bits 2]
         [tpe       : Bits Frame]
         [subType   : Bits 4]
         [toDS      : Bits 1]
         [fromDS    : Bits 1]
         [moreFrag  : Bits 1]
         [retry     : Bits 1]
         [powerMgmt : Bits 1]
         [moreData  : Bits 1]
         [wep       : Bits 1]
         [order     : Bits 1]
   in
         [frameControl]
         [duration  : Bytes 2]
         {Val(tpe)
           | Data ->
              [address1   : Bytes 6]
              [address2   : Bytes 6]
              [address3   : Bytes 6]
              [fragNumber : Bits 4]
              [seqNumber  : Bits 12]
              [address4   : Bytes 6]
           | Control ->
               {Val(subType)
                  | 11 -> [receiver : Bytes 6] [transmitter : Bytes 6]
                  | 12 -> [receiver : Bytes 6]
                  | _ -> nil
               }
           | other -> nil
         }
*)
