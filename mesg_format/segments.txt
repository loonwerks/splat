Message Formats via Segment Specifications.
============================================

  I particularly liked one of the core ideas of Robby's bitCodec,
namely, the association of the name of a field with its width. The
following focuses purely on that, aiming at a simple declarative basis
for expressing how a buffer gets chopped up into segments. Given the
segments substrate, extra semantic freight can be added fairly easily
to each segment. The goal is to inter-operate smoothly with bitCodec
specifications expressed in AADL, while also providing a declarative
basis on which to do SPLAT proofs. Perhaps it will be useful for Dave
Greve as well.

I see three main building blocks for specifying the fields of a
message, together with their widths. These building blocks can be
combined to build a full message.

  1. Static. Example: "field A takes 8 bits"

  2. Dynamic. 
     Example: "the width of field B is 4 times the value of field A"

  3. Superposition.  
     Example: "if the value of field A is 0 then the rest of the
     message has fields B,C,D (along with their widths); otherwise,
     the rest of the message has fields P,Q,R,S (along with their
     widths)."

Remarks.

- Static and Dynamic specs refer to an individual field, while a
  Superposition tells us the ways in which the entirety of the
  remainder of the message is structured, depending on the contents of
  an already seen field.

- Superposition and the "Union" constructor from bitCodec are
  essentially the same. 

- Dynamic and Superposition specs require the *value* of a field to be
  computed during decoding in order to correctly continue
  decoding. Such a value is usually if not always a natural
  number.

- A Dynamic spec is essentially a beta-redex that needs a value from
  an earlier field before it can fire. This reminded me of the "let"
  construct from functional programming.


Examples 
---------

The examples use an idealized concrete syntax with non-standard let
bindings. All widths express the number of bits.

A. The expression

     let A = 4;
         B = 3;
     in [A;B]

  specifies a message with two fields A and B, the first of length 4
  and the second of length 3. The corresponding decoder expects a list
  of bits of length 7 and breaks it into two parts. The encoder takes
  fields A and B and writes them out into 4-bits and 3 bits,
  respectively, failing if either A or B is too large for their
  allocation of bits.

B. Assume "Val" maps n-length bitstrings to unsigned numbers. Then
   the expression

     let A = 4;
         B = 8 * Val(A);
     in [A;B]

   denotes a message with two fields A and B, the first of length 4
   and the second with length equal to 8 times the value of field
   A. The value of field A can range from 0 to 15. The decoder
   generated from this specification takes the first 4 bits, evaluates
   them to a number n, then expects the B field to be 8*n in
   length. The result of decoding is two fields of bits (not numbers).

C. The expression

     let A = 4;
         B = 13;
     in if Val(A) = 0 then
           [A;B]
        else let C = 1024;
                 D = 14;
             in [A;C;D]
        
   denotes a message that uses the value of the first field to
   determine whether the full message has two fields (and length 17)
   or three fields (total length 1042).


Discussion
-----------

- The use of let-bindings in segment specifications is useful because
  it directly specifies the environment to be used when computing
  values for Dynamic or Superposition fields.

- Besides the basic skeleton of let-binding, this approach also needs
  a small language of expressions built from variables.

Abstract Syntax
----------------

The concrete syntax above has an abstract counterpart. In SML syntax we
have the following datatype

  datatype segments
    = Segs of string list
    | Cseg of (string * iexp) * segments
    | Union of iexp * (int -> segments)

which builds upon a small language of integer expressions (can be
expanded as needed)

datatype iexp 
  = Val of string
  | Const of string
  | EnumName of string
  | intLit of int
  | Add of iexp * iexp
  | Mult of iexp * iexp
  | Diff of iexp * iexp

fun Eval (E as (fldEnv:string -> int,cEnv,eEnv)) e =
 case e
  of Val s      => fldEnv s
   | Const s    => cEnv s
   | Enum p     => eEnv p
   | intLit i   => i
   | Add(e1,e2) => Eval E e1 + Eval E e2 
   | Mult(e1,e2) => Eval E e1 * Eval E e2 
   | Diff(e1,e2) => Eval E e1 - Eval E e2 ;

fun Bits n = intLit n;
fun Bytes n = intLit (n * 8);

Then the examples are represented as

A:   Cseg(("A", Bits 4),
     Cseg(("B", Bits 3),
     Segs ["A","B"])) 

B:   Cseg(("A", Bits 4),
     Cseg(("B", Mult(Bits 8,Val("A")),
     Segs ["A","B"])) 

C:   Cseg(("A", Bits 4),
     Cseg(("B", Bits 13),
     Union(Val"A",
        fn i => if i = 0 then 
                  Segs ["A","B"]
                else 
                  Cseg(("C", Bits 1024),
                  Cseg(("D", Bits 14),
                  Segs ["A","C","D"])))))

Note: The Union constructor takes an expression and a meta-language
function (in ML, HOL, Slang, or what-have-you). Alternatively, the
meta-language function can be dispensed with in favor of supplementing
the iexp datatype with support for some kind of case-splitting.

802.11 Header Example.
----------------------

(*
"Declare_Enum Frame = Management | Control | Data | Reserved"

defines datatype, encoder, decoder, and width:
*)

datatype Frame = Management | Control | Data | Reserved;

fun Frame_enc Management = 0
  | Frame_enc Control = 1
  | Frame_enc Data = 2
  | Frame_enc Reserved = 3;

fun Frame_dec 0 = Management
  | Frame_dec 1 = Control
  | Frame_dec 2 = Data
  | Frame_dec 3  = Reserved
  | Frame_dec n = failwith "Frame_dec";

fun enum_width "Frame" = 2;

val macHeader = 
 Cseg (("protocol",  Bits 2),
 Cseg (("tpe",       Bits (enum_width "Frame")),
 Cseg (("subType",   Bits 4),
 Cseg (("toDS",      Bits 1),
 Cseg (("fromDS",    Bits 1),
 Cseg (("moreFrag",  Bits 1),
 Cseg (("retry",     Bits 1),
 Cseg (("powerMgmt", Bits 1),
 Cseg (("moreData",  Bits 1),
 Cseg (("wep",       Bits 1),
 Cseg (("order",     Bits 1),
 Cseg (("duration",  Bytes 2),
 Union(Val "tpe", fn i => 
  if i = Frame_enc Data then 
       Cseg(("address1",   Bytes 6),
       Cseg(("address2",   Bytes 6),
       Cseg(("address3",   Bytes 6),
       Cseg(("fragNumber", Bits 4),
       Cseg(("seqNumber",  Bits 12),
       Cseg(("address4",   Bytes 6),
       Segs["protocol", "tpe", "subType", "toDS","fromDS", 
            "moreFrag", "retry", "powerMgmt", "moreData", 
            "wep", "order","duration", "address1","address2",
            "address3", "fragNumber","seqNumber", "address4"]
           ))))))
  else
  if i = Frame_enc Control 
  then Union (Val "subType", fn j => 
       if j = 12 then 
          Cseg(("receiver", Bytes 6),
          Segs["protocol", "tpe", "subType", 
               "toDS","fromDS", "moreFrag", 
               "retry", "powerMgmt", "moreData", 
               "wep","order","duration","receiver"])
       else
       if j = 11 then
          Cseg(("receiver",    Bytes 6),
          Cseg(("transmitter", Bytes 6),
          Segs["protocol", "tpe", "subType", "toDS","fromDS", 
               "moreFrag", "retry", "powerMgmt", "moreData", "wep", 
               "order","duration","receiver","transmitter"]
              ))
       else Segs [])
  else Segs []
 )))))))))))))
;


Semantics
---------

The syntax is essentially a way of specifying sets of strings, as in
formal language theory. In fact, the language of segments is very much
like the concept of regular grammars from formal language theory
(augmented with some non-regular features). In a binding

  let A = rhs in ...

rhs is an expression denoting the length of segment A, and we model
this by translating the syntax to 

  let A = .{rhs} in ...

in which dot (.) denotes "any bit" and .{n} denotes an arbitrary
bitstring of length n. Thus each let binding denotes a formal language
and the final result is the concatenation of languages. This ends up
in complications.

Rather, I went to a predicate on bitstrings approach:

HOL
---

load "numposrepTheory";

Definition Bits_def : 
  Bits (n:num) = n
End;

Definition Bytes_def : 
  Bytes n = n * 8
End;

Hol_datatype `Frame = Management | Control | Data | Reserved`;

Definition Frame_enc_def :
  Frame_enc Management = 0 /\
  Frame_enc Control    = 1 /\
  Frame_enc Data       = 2 /\
  Frame_enc Reserved   = 3
End

Definition Frame_width : 
  Frame_width = Bits 2
End;

Definition WIDTH_def : 
 WIDTH L n <=> (LENGTH L = n)
End

Definition macHeader_segments_def :
 macHeader_segments L <=>
   ?frameControl
    protocol tpe subType toDS fromDS moreFrag retry 
    powerMgmt moreData wep order duration. 
     (frameControl = protocol ++ tpe ++ subType ++ 
                     toDS ++ fromDS ++ moreFrag ++ 
                     retry ++ powerMgmt ++ moreData ++ 
                     wep ++ order) /\
      WIDTH protocol  (Bits 2)  /\
      WIDTH tpe    Frame_width  /\
      WIDTH subType   (Bits 4)  /\
      WIDTH toDS      (Bits 1)  /\
      WIDTH fromDS    (Bits 1)  /\
      WIDTH moreFrag  (Bits 1)  /\
      WIDTH retry     (Bits 1)  /\
      WIDTH powerMgmt (Bits 1)  /\
      WIDTH moreData  (Bits 1)  /\
      WIDTH wep       (Bits 1)  /\
      WIDTH order     (Bits 1)  /\
      WIDTH duration  (Bytes 2) /\
   if decN tpe = Frame_enc Data then
      (?address1 address2 address3 fragNumber seqNumber address4. 
         WIDTH address1   (Bytes 6) /\
         WIDTH address2   (Bytes 6) /\
         WIDTH address3   (Bytes 6) /\
         WIDTH fragNumber (Bits 4)  /\
         WIDTH seqNumber  (Bits 12) /\
         WIDTH address4   (Bytes 6) /\
         L = frameControl ++ duration ++ 
             address1 ++ address2 ++ address3 ++ 
             fragNumber ++ seqNumber ++ address4)
   else 
   if (decN tpe = Frame_enc Control) /\ (decN subType = 12) then
      (?receiver. WIDTH receiver (Bytes 6) /\
         L = frameControl ++ duration ++ receiver)
   else
   if (decN tpe = Frame_enc Control) /\ (decN subType = 11) then
      (?receiver transmitter. 
        WIDTH receiver    (Bytes 6) /\
        WIDTH transmitter (Bytes 6) /\	
        L = frameControl ++ duration ++ receiver ++ transmitter)
   else F
End;
	

(*---------------------------------------------------------------------------*)
(* Looking for an elegant and unambiguous syntax.                            *)
(*---------------------------------------------------------------------------*)
(*
macHeader =
   let frameControl = 
         [protocol  : Bits 2]
         [tpe       : Bits Frame] 
         [subType   : Bits 4]
         [toDS      : Bits 1]
         [fromDS    : Bits 1]
         [moreFrag  : Bits 1]
         [retry     : Bits 1]
         [powerMgmt : Bits 1]
         [moreData  : Bits 1]
         [wep       : Bits 1]
         [order     : Bits 1]
   in
         [frameControl]
         [duration  : Bytes 2]
         {Val(tpe)
           | Data -> 
               [address1   : Bytes 6]
               [address2   : Bytes 6]
               [address3   : Bytes 6]
               [fragNumber : Bits 4]
               [seqNumber  : Bits 12]
               [address4   : Bytes 6]
           | Control -> 
               {Val(subType)
                  | 11 -> [receiver : Bytes 6] [transmitter : Bytes 6]
                  | 12 -> [receiver : Bytes 6]
                  | _ -> nil
               }
           | other -> nil
         }
*)


Adding More Semantics
----------------

- Bit/byte order
- Signed encodings
- Byte alignment

Issues yet to discuss:
----------------------

Sizeof. Would be nice to have a sizeof operator, defined on
types. Begs the question of having a type system, including arrays,
and user-defined enumerations.

Arrays.
--------

  Notation : [A : sizeof (<type> [d1,...,dk])]

  where d1, ..., dk are iexps

Replication (Intervals)
-----------------------

 Notation : [A : (lo,hi)]

  where lo, and hi are iexps

Example :

  [A : (Bytes 5, Bytes 2024)] 

This can be supported by making all field widths into intervals.  But
then have to worry about iexp operations and how they extend to work
over intervals rather than ints.


Non-left-dependent computations.
--------------------------------

ipv4 checksum checksums all fields of header, counting itself as 0,
then writes the checksum field, which is not at the end of the header.


(Also shows that user-defined computations needed to be supported.)
