SPLAT Syntax.
-----------------

 Splat generates code for filters, monitors, and gates expressed in a
restricted, but expressive, subset of AADL+AGREE. If Splat is given a
model whose syntax is outside this subset it will certainly fail to
produce code from the model. If, however, it is given a properly
expressed model, it will producte CakeML code that will be compiled
into the final system by HAMR.

The current version of Splat does not generate proofs as part of its
execution; that will be added in the next phase of work.


Expected Syntax of Specifications.
----------------------------------

Briefly:

 - Basic AADL types (booleans, numbers, characters, records, arrays,
   variants) and constants and definitions over those types are
   handled properly.

   [Restrictions? E.G. array initialization ...]

 - Basic AGREE types (int, real) denote mathematical numbers and so
   are unbounded. Splat will map an int to a default bitwidth and
   interpretation (currently bits = 32, format is little-endian, and
   encoding is twos-complement), settable when Splat is
   invoked.

 - Splat doesn't currently support

      * Temporal logic constructs
      * Lustre node definitions


Code Guarantees Have an Expected Form
--------------------------------------

A "Code Guarantee" is a guarantee able to be interpreted by the Splat
code generator. It specifies how the component outputs are to be
produced. There are 3 possible forms expected for a code guarantee,
depending on the output port type.

1. Event port. The expected form is

      event(port) = exp

    This indicates that port is an event port and it will be set (or not)
    according to the value of exp, which is boolean.

2. Data port. The expected form is

      port = exp

    This indicates that port is a data port and that the value of exp
    will be written to it.

3. Event data port. The expected form is

      if exp1 then
        event (port) and port = exp2
      else
        not (event port);

    This checks the condition exp1 to see whether an event on port will
    happen, and exp2 gives the output value if so. Note that any input
    event (or event data) port p occurring in exp2 must be guaranteed to
    have an event by event(-) checks in exp1.

In all of 1,2,3, the expressions should not mention any output ports,
i.e. the value to be sent out is determined by a computation over input
ports and state variables only.


Syntactic Restrictions and Things to be Aware of
-------------------------------------------------

1. `eq` statements are assumed to be written in dependency order

1a. Discussion of input, initialization, nad e1 -> e2

2. Array indices in AGREE/AADL are 1-based

3. Decoders are there; encoders are not. This means that output ports
   can either pass on (or not) the contents of input ports, but that
   sending *other* kinds of data out is not currently supported.
