\documentclass{beamer}
\usetheme{metropolis}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsbsy}
\usepackage{alltt}
\usepackage{tikz}
\usetikzlibrary{shapes}
\usepackage{stmaryrd}
\usepackage{graphicx}

\newcommand{\imp}{\Rightarrow}
\newcommand{\etal}{\textit{et. al}}
\newcommand{\adhoc}{\textit{ad hoc}}
\newcommand{\ie}{\textit{i.e.}}
\newcommand{\etc}{\textit{etc}}
\newcommand{\eg}{\textit{e.g.}}
\newcommand{\kemph}[1]{\colorbox{orange}{#1}}
\newcommand{\konst}[1]{\ensuremath{\mbox{\bf{#1}}}}
\newcommand{\nil}{\konst{[\,]}}
\newcommand{\cons}[2]{{#1}\boldsymbol{:}\boldsymbol{:}{#2}}
\newcommand{\hollamb}{\boldsymbol{\lambda}}
\newcommand{\itelse}[3]{\mbox{$\mbox{\tt if}\ {#1}\ \mbox{\tt then}\ {#2}\
    \mbox{\tt else}\ {#3}$}}
\newcommand{\set}[1]{\{ {#1} \}}
\newcommand{\Lang}[1]{\ensuremath{{\cal L}({#1})}}
\newcommand{\LangTheta}[1]{\ensuremath{{\mathcal L}_{\theta}({#1})}}
\newcommand{\inbox}[1] {\begin{center}
                         \framebox{\parbox{0.984\textwidth}{#1}}
                         \end{center}}

% for backslashes in alltt environments
\newcommand{\bs}{\texttt{\symbol{92}}}

\begin{document}

% Title page

\author{Konrad Slind \\ Collins Aerospace ATC}
\date{Staff Meeting, Dec. 15, 2020}
\title{Modelling CASE System Behavior}
\maketitle

\begin{frame}\frametitle{Overview}

\begin{enumerate}
\item CASE Semantic Stew
\item AADL Threads and Lustre
\item Extension to Traces
\item Predicate logic view of system behavior
\item What are the interesting system properties?
\end{enumerate}
\end{frame}


\section {CASE Semantic Stew}

\begin{frame}\frametitle{AADL}
\begin{itemize}
\item [$\blacktriangleright$] Architecture Description Language
\item [$\blacktriangleright$] Beyond boxes and arrows, it has a ``runtime system''
\item [$\blacktriangleright$] Essential for inter-component (and intra-) communication
\item [$\blacktriangleright$] Comms layer  (HAMR) that gets slathered on at \kemph{system build} time.
\item [$\blacktriangleright$] Semantics under development by John Hatcliff and others
\end{itemize}

\end{frame}

\begin{frame}\frametitle{AGREE/Lustre}
\begin{itemize}
\item [$\blacktriangleright$] \kemph{AGREE} provides reasoning about AADL component contracts
\item [$\blacktriangleright$] Embedded in AADL via annex extension capability
\item [$\blacktriangleright$] \kemph{Lustre} is used to describe (possibly stateful) computation
\item [$\blacktriangleright$] Also provides the formulas of the AGREE logic
\item [$\blacktriangleright$] AG-reasoning via $k$-induction model checkers (jKind, Kind)
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Past time Temporal Logic}
\begin{itemize}
\item [$\blacktriangleright$] Monitor behaviors specified by formulas (\kemph{policies}) in pt-LTL
\item [$\blacktriangleright$] pt-LTL + Lustre is very expressive
\item [$\blacktriangleright$] pt-LTL can be translated cleanly to Lustre
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Regexps and Contiguity Types}
\begin{itemize}
\item [$\blacktriangleright$] \kemph{Regexps} used to specify simple DFA-based filters
\item [$\blacktriangleright$] \kemph{Contig. types} used to specify complex filters
\item [$\blacktriangleright$] Semantics (formal language theory) and correctness proofs in HOL4
\item [$\blacktriangleright$] Extension to trace level by Johannes at Data61 (CakeML)
\end{itemize}
\end{frame}

\begin{frame}\frametitle{CakeML and seL4}
\begin{itemize}
\item [$\blacktriangleright$] Formal compiler for CakeML (HOL4)
\item [$\blacktriangleright$] Verified OS (Isabelle/HOL)
\item [$\blacktriangleright$] Very large formalizations
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Attestation}
\begin{itemize}
\item [$\blacktriangleright$] Modelling and implementation of remote attestation framework
\item [$\blacktriangleright$] Modelling in Coq
\item [$\blacktriangleright$] Implementation in CakeML
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Comments}
\begin{itemize}
\item [$\blacktriangleright$] An amazing jumble of \kemph{formal stuff}
\item [$\blacktriangleright$] We want to have a coherent view
\item [$\blacktriangleright$]
\kemph{$\set{\konst{AGREE},\konst{pt-LTL}}$} map to Lustre
\item [$\blacktriangleright$]
  \kemph{$\set{\konst{Regexp},\konst{contig},\konst{CakeML}, \konst{seL4}}$} map to higher order logic
\item [$\blacktriangleright$] Many remaining gaps
\end{itemize}
\end{frame}


\section {AADL Threads and Lustre}

\begin{frame}\frametitle{AADL Threads}

\konst{Assumption} An AADL thread/component has the following
behavior: when the scheduler picks it to run

\begin{itemize}
\item [$\blacktriangleright$] it reads its input ports,
\item [$\blacktriangleright$] performs its computation, which might use and modify persistent state
\item [$\blacktriangleright$] writes its output ports
\item [$\blacktriangleright$] gets put back in the queue

\end{itemize}

\konst{Another Assumption} This takes zero time
\end{frame}

\begin{frame}\frametitle{`performs its computation`}

The computation can be modelled by a function

\[
\konst{stepFn} : \mathit{inports} \times \mathit{stateVars} \to \mathit{stateVars}
\]

that will be called in the context

\[
\begin{array}{ll}
 \mathit{inportVals} & = \konst{readInputs}(); \\
 (v_1,\ldots,v_k) & = \konst{readState}() ; \\
 ({v_1}',\ldots,{v_k}') & = \kemph{\konst{stepFn}} (\mathit{inportVals},\mathit{stateVars}) ; \\
 \multicolumn{2}{l}{\konst{writeState}({v_1}',\ldots,{v_k}');} \\
 \multicolumn{2}{l}{\konst{writeOutputs}({v_1}',\ldots,{v_k}');} \\
\end{array}
\]

\end{frame}

\begin{frame}\frametitle{Lustre semantics}

The \kemph{\konst{stepFn}} is synthesized from all the Lustre
`\konst{eq}' statements given in the AADL annex for a
component. Lustre semantics has some subtleties:

\begin{itemize}
\item [$\blacktriangleright$] State variables need to be evaluated in dependency order

\item [$\blacktriangleright$] Once a state variable is assigned to,
  its new value gets used in computing the values of variables that
  depend on it.

\item [$\blacktriangleright$] Lustre `\konst{eq}' statements of the form
\[ \mathit{init} \to \mathit{step}
\]
need to be written taking into account that $\mathit{init}$ code will
be invoked in a setting where the first inputs to the component have been read.

\item [$\blacktriangleright$] (Eh?) Variable initialization \kemph{and}
  processing first input port values happens in the first step.


\end{itemize}

\end{frame}

\begin{frame}[fragile]\frametitle{Example}

Consider a Lustre program that keeps a running maximum of two integer
input ports, signaling an alert if the max. ever is 42.

\konst{MAX} takes the max. of two integers.

{\small
\begin{verbatim}
  max = 0 -> MAX (MAX(in1,in2), pre max)
  alert = (max = 42)
\end{verbatim}
}

But this will miss inputs at time 0. Repaired by changing to

{\small
\begin{verbatim}
  max = MAX(in1,in2) -> MAX (MAX(in1,in2), pre max)
  alert = (max = 42)
\end{verbatim}
}

\end{frame}

\begin{frame}[fragile]\frametitle{Example (stepFn)}

{\small
\begin{verbatim}
  stepFn (in1,in2) (initStep,max,alert) =
      if initStep then
        let val max' = MAX(in1,in2)
            val alert' = (max' = 42)
        in (False,max',alert')
        end
      else
        let val max' = MAX(MAX(in1,in2),max)
            val alert' = (max' = 42)
        in (False,max',alert')
        end
\end{verbatim}
}

\end{frame}

\section {From Steps to Traces}

\begin{frame}\frametitle{Traces and step functions}

A trace $\konst{Tr} = \konst{Tr}_0,\konst{Tr}_1,\konst{Tr}_2, \ldots$
can be modelled by a function $\mathbb{N}\to\tau$, where $\tau$ is the
type of the elements of the trace.

\begin{itemize}
\item [$\blacktriangleright$] (Foreshadowing) We ultimately want to
  think about the behavior of the entire system as a predicate on the
  traces representing the external ports of the system.

\item [$\blacktriangleright$] For a component $C$ with synthesized $\konst{stepFn}_{C}$, we
  want to build the corresponding trace $\konst{Tr}_{C}$ and show

\[ \vdash \forall t. \; \konst{stepFn}^{t}\;\mathit{dummy} = \konst{Tr}_{C}(t) \]

\item [$\blacktriangleright$] In other words, the trace agrees with
  iterating the step function, beginning with a dummy state
  $\mathit{dummy}$.

\end{itemize}

\end{frame}


\begin{frame}\frametitle{Traces and step functions contd}

\begin{itemize}

\item [$\blacktriangleright$] The trace can be (automatically) defined
  by recursion, guided by the structure of the step function.

\item [$\blacktriangleright$] Equivalence proof can be automated (in progresss). The essence
  is showing the iteration is equal to the recursion.

\item [$\blacktriangleright$] Subsequently we can use $\konst{Tr}_{C}$ in
  further formal modelling, abstracting away from the computational
  details of the step function.

\end{itemize}

\end{frame}

\begin{frame}[fragile]\frametitle{Example Trace construction}

\[ \konst{TRACE} : (\mathbb{N}\to\konst{int}, \mathbb{N}\to\konst{int})
 \to (\mathbb{N}\to\konst{int}, \mathbb{N}\to\konst{bool})
 \to \mathbb{N}\to\konst{bool}
\]

{\small
\begin{verbatim}
  TRACE (In1,In2) (Max,Alert) 0 <=>
     (Max 0 = MAX (In1 0, In2 0))
     and
     (Alert 0 = (Max 0 = 42))

  TRACE (In1,In2) (Max,Alert) (t+1) <=>
     (Max (t+1) = MAX(MAX (In1 (t+1), In2 (t+1)), Max(t)))
     and
     (Alert (t+1) = (Max (t+1) = 42))
\end{verbatim}
}

\end{frame}

\begin{frame}\frametitle{What is the point?}

By giving semantics to Lustre programs running under the guarantees of
the AADL runtime, we can represent CASE component behavior in
predicate logic.

Also ... AGREE properties may have to be adjusted in light of this semantics.

\end{frame}

\section {Predicate Logic view of System Behavior}


\end{document}
