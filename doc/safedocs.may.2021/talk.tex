\documentclass{beamer}
\usetheme{metropolis}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsbsy}
\usepackage{alltt}
\usepackage{tikz}
\usetikzlibrary{shapes}
\usepackage{stmaryrd}
\usepackage{graphicx}

\newcommand{\imp}{\Rightarrow}
\newcommand{\etal}{\textit{et. al}}
\newcommand{\adhoc}{\textit{ad hoc}}
\newcommand{\ie}{\textit{i.e.}}
\newcommand{\etc}{\textit{etc}}
\newcommand{\eg}{\textit{e.g.}}
\newcommand{\kemph}[1]{\colorbox{orange}{#1}}
\newcommand{\highlight}[2][orange]{\mathchoice%
  {\colorbox{#1}{$\displaystyle#2$}}%
  {\colorbox{#1}{$\textstyle#2$}}%
  {\colorbox{#1}{$\scriptstyle#2$}}%
  {\colorbox{#1}{$\scriptscriptstyle#2$}}}%

\newcommand{\konst}[1]{\ensuremath{\mbox{\bf{#1}}}}
\newcommand{\nil}{\konst{[\,]}}
\newcommand{\cons}[2]{{#1}\boldsymbol{:}\boldsymbol{:}{#2}}
\newcommand{\hollamb}{\boldsymbol{\lambda}}
\newcommand{\itelse}[3]{\mbox{$\mbox{\tt if}\ {#1}\ \mbox{\tt then}\ {#2}\
    \mbox{\tt else}\ {#3}$}}
\newcommand{\set}[1]{\{ {#1} \}}
\newcommand{\Lang}[1]{\ensuremath{{\cal L}({#1})}}
\newcommand{\LangTheta}[1]{\ensuremath{{\mathcal L}_{\theta}({#1})}}
\newcommand{\inbox}[1] {\begin{center}
                         \framebox{\parbox{0.984\textwidth}{#1}}
                         \end{center}}

% for backslashes in alltt environments
\newcommand{\bs}{\texttt{\symbol{92}}}

\begin{document}

% Title page

\author{Konrad Slind \\ Collins Aerospace \\ \\ SafeDocs PI Meeting}
\date{May 25, 2021}
\title{SafeDocs and CASE}
\maketitle

\begin{frame}\frametitle{Overview}

\begin{enumerate}
\item Security-Enhancing Architectural Transformations in \konst{CASE}
\item Contiguity Types: Status Report
\item Monitors and Code Generation
\item Future Directions
\end{enumerate}
\end{frame}


\section {Context: Architectural Transformations in CASE}

\begin{frame}\frametitle{System Architecture Languages}
\begin{itemize}

\item General setting: \textbf{Architectural Design Languages}

\item An ADL supports complete, highly abstract, views of a system,
  including hardware, software, (and possibly humans)

\item An architecture model should provide a high-level setting in which
  the \kemph{whole picture} of a system can be surveyed

\item Thus: a place where existing implementations, new design
  features, high-level requirements, implementations, and
  verifications can be combined.

\item Not just boxes and arrows!

\end{itemize}

\end{frame}

\begin{frame}\frametitle{CASE}
\begin{itemize}

\item In the DARPA \textbf{CASE} project we are developing the idea of
  \kemph{Security-Enhancing} transformations on system architecture
  descriptions.

\item Acronym: \colorbox{orange}{SEAT}

\item The goal is to develop a methodology and case studies where
  \begin{itemize}
  \item [$\blacktriangleright$]
       the structure of an existing (legacy) system is captured in an architectural model;

 \item [$\blacktriangleright$] system security is automatically analyzed and any security
   problems are addressed by applying architectural transformations
 \end{itemize}

\item A key aspect is use of formal specification languages and
  automatic synthesis of security mechanisms.

\end{itemize}

\end{frame}

\begin{frame}[fragile]\frametitle{CASE Website}

Check it out:

\begin{verbatim}
  http://loonwerks.com/projects/case.html
\end{verbatim}

\end{frame}


\begin{frame}\frametitle{Architecture Transformations}

An architecture-to-architecture map that can be applied to
\kemph{provably increase} the security of a system.

\vspace*{4mm}

\includegraphics[width=90mm,height=50mm]{arch-trans.jpg}
\end{frame}

\begin{frame}\frametitle{Transformation: Message Filtering}

A \emph{filter} is conceptually very simple: it checks validity of its
input data according to predicate $P$.


\begin{center}
\begin{tikzpicture}[
redsquarednode/.style={rectangle, draw=red!60, fill=red!5, very thick, rounded corners, minimum size=10mm},
greensquarednode/.style={rectangle, draw=green!60, fill=green!5, very thick, rounded corners, minimum size=10mm},
fat arrow/.style={single arrow,thick,draw=blue!70,fill=blue!30,minimum height=35mm,minimum width=7mm}
]
%Nodes
\node[draw,greensquarednode] at (2,0) (SRC)    {A};
\node[draw,greensquarednode] at (5,0) (TARGET) {B};

\node at (3.5,-1.5) [fat arrow]{};

\node[draw,greensquarednode] at (0,-3) (SRC-1)    {A};
\node[draw,greensquarednode] at (6,-3) (TARGET-1) {B};
\node[draw,redsquarednode] at (3,-3) (FILTER) {FILTER(P)};

%Lines
\draw[->,very thick] (SRC.east) -- (TARGET.west);

\draw[->,very thick] (SRC-1.east) -- (FILTER.west);
\draw[->,very thick] (FILTER.east) -- (TARGET-1.west);
\end{tikzpicture}
\end{center}

%% \hspace*{10mm}\includegraphics[width=90mm,height=50mm]{filter.jpg}

If the data is valid, then it is passed on. Otherwise it is dropped.

\end{frame}


\begin{frame}\frametitle{Transformation: Message Monitoring}

A \emph{monitor} checks to see that a relationship $\mathcal{R}$ holds
over a collection of message streams through time. If the
specification is violated, an \emph{alert} is sent out.

\begin{center}
\begin{tikzpicture}[
redsquarednode/.style={rectangle, draw=red!60, fill=red!5, very thick, rounded corners, minimum size=10mm},
greensquarednode/.style={rectangle, draw=green!60, fill=green!5, very thick, rounded corners, minimum size=10mm},
fat arrow/.style={single arrow,thick,draw=blue!70,fill=blue!30,minimum height=60mm,minimum width=7mm}
]
%Nodes
\node[draw,greensquarednode] at (1,0) (A) {A};
\node[draw,greensquarednode] at (4,0) (B) {B};
\node[draw,greensquarednode] at (7,0) (C) {C};
\node at (9,0) (D) {};

\node at (4.5,-1.5) [fat arrow]{};

\node[draw,greensquarednode] at (1,-3) (A-1) {A};
\node at (2.25,-3) (joinAB) {};
\node[draw,greensquarednode] at (4,-3) (B-1) {B};
\node at (5.25,-3) (joinBC) {};
\node[draw,greensquarednode] at (7,-3) (C-1) {C};
\node at (8.25,-3) (joinCD) {};
\node at (9,-3) (D-1) {};
\node[draw,redsquarednode]   at (4,-5) (M) {Monitor($\mathcal{R}$)};
\node at (8,-5) (ALERT-TARGET) {\textit{Alert-target}};

%Lines
\draw[->,very thick] (A.east) -- (B.west);
\draw[->,very thick] (B.east) -- (C.west);
\draw[->,very thick] (C.east) -- (D.west);
\draw[->,very thick] (A-1.east) -- (B-1.west);
\draw[->,very thick] (B-1.east) -- (C-1.west);
\draw[->,very thick] (C-1.east) -- (D-1.west);

\draw[->,very thick] (2.25,-3) to [out=-90, in=180] (M);
\draw[->,very thick] (5.25,-3) to [out=-30, in=90]  (M);
\draw[->,very thick] (8.25,-3) to [out=-30, in=45]  (M.north east);
\draw[->] (M.east) -- (ALERT-TARGET);

\end{tikzpicture}
\end{center}

%% \hspace*{10mm}\includegraphics[width=90mm,height=40mm]{monitor.jpg}

\end{frame}

\begin{frame}\frametitle{Transformation: Message Monitoring}

 We currently use past-time temporal logic, encoded in Lustre, to
 specify monitor behavior. From that we synthesize implementations in CakeML.

\end{frame}


\begin{frame}\frametitle{Transformation: Isolation of `at risk' components}

An unprotected computational element can be isolated by transparently
lifting it out of its context and mediating access via seL4.

\begin{center}
\begin{tikzpicture}[
bignode/.style =
  {rectangle,
   draw=green!60, fill=green!5,
   very thick, rounded corners,
   minimum height=20mm, minimum width = 20mm},
flatnode/.style =
  {rectangle,
   draw=red!60, fill=red!5,
   very thick, rounded corners,
   minimum width = 40mm},
fat arrow/.style={single arrow,thick,draw=blue!70,fill=blue!30,minimum height=30mm,minimum width=7mm}
]
%Nodes
\node[draw,bignode](main){A};
\node[draw,fill=orange!60] (atrisk) at ([yshift=2ex]main.south){C};
\node (comment) at ([xshift=-10ex]main.west){`At risk'};
\draw[->] (comment) -- (atrisk);
\node at ([yshift=-3ex]main.south) [fat arrow]{};
\node[draw,bignode](main-1) at ([yshift=-12ex]main.south){A};
\node[draw,fill=orange!60] (secure) at ([xshift=3.5ex,yshift=2ex]main-1.south east){C};
\node[draw,flatnode] (seL4) at ([yshift=-2ex]main-1.south){seL4};
\node[draw,fill=black,circle,scale = 0.2] (origin) at ([yshift=1ex]main-1.south){};
\node (foo) at ([yshift=-2ex,xshift=4ex]seL4.north){};
\draw (origin) -- (foo.center);
\draw[->] (foo.center) -- (secure.south);
\end{tikzpicture}
\end{center}

%\filldraw[black] (0,0) circle (2pt) node[anchor=west] {Intersection point};
%\hspace*{10mm}\includegraphics[width=90mm,height=40mm]{vm.jpg}

\end{frame}

\begin{frame}\frametitle{seL4}

Correctness of this transformation depends on formal guarantees provided by seL4.

\begin{itemize}
\item seL4 microkernel guarantees partitioning of components and
  communication, backed by computer-checked proofs

\item seL4 guarantees no infiltration, exfiltration, eavesdropping,
  interference, and provides fault containment for untrusted code

\end{itemize}

\vspace*{5mm}
\hspace*{10mm}\includegraphics[width=15mm,height=15mm]{data61-logo.png}
\hspace*{10mm}\includegraphics[width=15mm,height=15mm]{csiro--black.png}

\end{frame}

\begin{frame}\frametitle{Transformation: Attestation}

Attestation inserts measurement mechanisms into a system. These
examine various aspects of system behavior, and send summaries back to
an observer system.

%% %% \newcommand\rightEye[1][1.2ex]
%% %% {%
%% %% \begin{tikzpicture}[scale=#1/1cm]
%% %%   \draw (0,0) circle (.5);
%% %%   \fill (.25,0) circle (.25);
%% %% \end{tikzpicture}%
%% %% }

%% \begin{center}
%% \begin{tikzpicture}[
%% lefteyes/.style =
%%   {circle,
%%    draw=red!60, fill=red!5,
%%    minimum height=20mm, minimum width = 20mm}
%% ]
%% %Nodes
%% \draw (0,0) rectangle (1,1);
%% \draw (3,0) rectangle (1,1);

%% \draw (0,-3) rectangle (1,1);
%% \draw (3,-3) rectangle (1,1);
%% \draw (3,-3.5) rectangle (0.5,0.5);

%% \draw (3,-4) circle (.5);
%% \fill (3.25,-4) circle (.25);
%% \end{tikzpicture}
%% \end{center}

\hspace*{10mm}\includegraphics[width=90mm,height=40mm]{att.jpg}


\end{frame}

\begin{frame}\frametitle{CakeML implementations}

  The filter, monitor, and attestation transforms generate \konst{CakeML} implementations.

\begin{itemize}
 \item [$\blacktriangleright$] CakeML is a formally verified ML compiler

\item This allows a theorem that connects the high-level spec of a
  component with the execution of the binary on an ISA.
\end{itemize}

\end{frame}


\section{Contiguity Types : Status Report}

\begin{frame}\frametitle{Contiguity Types}

  \emph{Contiguity types} provide a small but expressive DSL for
specifying message formats, especially those with
\kemph{self-describing} aspects such as length fields and
`unions'.

\vspace*{5mm}
Filters and parsers can be automatically generated from
contiguity type specifications, backed up by a formal correctness
proof.

\end{frame}

\begin{frame}\frametitle{Contiguity Types: Syntax and Semantics}

\[
\begin{array}{rcl}
 \tau & = & \konst{bool} \mid \konst{char} \mid \konst{u8} \mid
 \konst{u16} \mid \konst{u32} \mid \konst{u64}  \mid \konst{i16} \mid
 \konst{i32} \mid \konst{i64} \mid \ldots \\
      & \mid & \konst{Recd}\; (f_1 : \tau_1) \ldots (f_n : \tau_n) \\
      & \mid & \konst{Array}\; \tau \; \mathit{exp} \\
      & \mid & \konst{Union}\; (\mathit{bexp}_1 : \tau_1) \ldots (\mathit{bexp}_n : \tau_n)
\end{array}
\]


\[
% \begin{array}{l}
\LangTheta{\tau} =
\mathtt{case}\; \tau\
% \hspace*{3mm}
 \left\{
 \begin{array}{l}
 \mathit{base} \Rightarrow \set{s \mid \konst{len}(s) = \konst{width}(base)} \\
 \konst{Recd}\; (f_1 : \tau_1) \ldots (f_n : \tau_n)
      \Rightarrow \LangTheta{\tau_1} \cdot \ldots \cdot \LangTheta{\tau_n}
\\
 \konst{Array}\; \tau_1 \; \mathit{exp}
      \Rightarrow  \LangTheta{\tau_1}^{\konst{evalExp}\;\theta\;\mathit{exp}}
\\
 \konst{Union}\; (\mathit{bexp}_1 : \tau_1) \ldots (\mathit{bexp}_n : \tau_n) \Rightarrow \\
  \hspace*{5mm}
 \left\{
 \begin{array}{ll}
    \LangTheta{\tau_i} &  \mathrm{if}\ \konst{evalBexp}\;\theta\;\mathit{bexp}_i = \konst{true} \\
                  & \mathrm{and\ no\ other}\ \mathit{bexp}_j\ \mathrm{is}\ \konst{true}  \\
    \emptyset & \mathrm{otherwise}
 \end{array}
 \right.
 \\
\end{array}
 \right.
%\end{array}
\]

\end{frame}

\begin{frame}[fragile]\frametitle{Soundness of matching}

A matching algorithm \konst{match} has been formalized and proved sound in HOL4.

\begin{theorem}[Matcher soundness]
%
\[
  \vdash \konst{match}\; \tau \; s =\konst{SOME}(\theta) \imp s \in \LangTheta{\tau}
\]
%
\end{theorem}

A successful match provides a context $\theta$ that will successfully
evaluate all encountered expressions, and the matched string is indeed
in the language of $\tau$.

To be done: a completeness theorem going in the other direction.

\end{frame}


\begin{frame}[fragile]\frametitle{Example: $A^n B^n C^n$}

{\small
\begin{verbatim}
  charA = {ch : char, isA : Assert (ch = 97)}
  charB = {ch : char, isB : Assert (ch = 98)}
  charC = {ch : char, isC : Assert (ch = 99)}

  mesg = {len : u16
            A : charA [len]
            B : charB [len]
            C : charC [len]
          }
\end{verbatim}
}

\[
\Lang{\mathit{mesg}} = u \cdot A^{\konst{val}(u)} \cdot B^{\konst{val}(u)} \cdot C^{\konst{val}(u)} \]

\end{frame}


\begin{frame}[fragile]\frametitle{Example: 2D array of GPS coords}

{\small
\begin{verbatim}
 AltitudeType = AGL | MSL

 Location3D = {
  Latitude  : double,
  Longitude : double,
  Altitude  : float,
  AltitudeType : AltitudeType,
  Wellformed : Assert (
      -90.0 <= Latitude <= 90.0 and
     -180.0 <= Longitude <= 180.0 and
      0.0 <= Altitude <= 15000.0)
  }

 Locations = {
    dims : {rows u16, cols : u16}
   table : Location3D [dims.rows * doms.cols]
  }
\end{verbatim}
}
\end{frame}


\begin{frame}\frametitle{Key ideas}

\begin{itemize}

\item [$\blacktriangleright$] \kemph{Systematic accumulation and
  exploitation of context.} As a contiguity type parser processes a
  message, each field is added to the context. Context is
  used in the computation of length fields, and in calculating which
  element of a union to choose.

\item [$\blacktriangleright$] \kemph{Context-sensitive sum.} There is
  no unadorned `sum' operation $L_1 \cup L_2$. Instead, we have a
  `guarded union` type
  $\konst{Union}\; (\mathit{bexp}_1 : \tau_1) \ldots (\mathit{bexp}_n : \tau_n)$
  where evaluation of the $\mathit{bexp}_i$, in the accumulated
  context, is used to determine which $\tau_i$ to continue parsing
  with.

\item [$\blacktriangleright$] \kemph{In-message assertions} Message
  constraints can be expressed within a contiguity type. This allows
  data constraints to be expressed alongside the data in the message
  specification.

\end{itemize}
\end{frame}

\begin{frame}\frametitle{Key ideas (contd)}

\begin{itemize}

\item [$\blacktriangleright$] \kemph{Message fields = memory
  locations.}  A contiguity type specification for a message format
  superimposes a C-like memory view on a message. Array length
  expressions and boolean choices in sums use R-values to compute
  values over already-seen message fields. This gives `dependent type'
  specification power without dependent types.

\item [$\blacktriangleright$] \kemph{Work at the string/byte buffer
  level.}  This allows us to avoid lifting message components to real
  types unnecessarily, \eg, when doing pure recognition as in a
  filter.

\end{itemize}
\end{frame}


\begin{frame}\frametitle{Extensions}

We are in the process of replacing the base types with a lexer and
have added unbounded lists (a form of Kleene Star):

\[
\begin{array}{rcl}
 \tau & =    & \highlight{\konst{Base}\; (\mathit{regexp} \times \mathit{valFn})} \\
      & \mid & \konst{Recd}\; (f_1 : \tau_1) \ldots (f_n : \tau_n) \\
      & \mid & \highlight{\konst{List}\; \tau} \\
      & \mid & \konst{Array}\; \tau \; \mathit{exp} \\
      & \mid & \konst{Union}\; (\mathit{bexp}_1 : \tau_1) \ldots (\mathit{bexp}_n : \tau_n)
\end{array}
\]

The lexer will support all the original fixed-width base types, along
with common lexemes for unbounded numbers, string literals, and
\adhoc{} field widths for packed encodings.

\end{frame}


\begin{frame}[fragile]\frametitle{List types}

The \kemph{List} constructor is used for parsing structures where the
number of elements is unknown at the outset.

\begin{itemize}

\item [$\blacktriangleright$] Encoded as a sequence of \konst{ConsTag}ed elements
  terminated with a \konst{NilTag}:

\[
  \konst{List}\, \tau = \konst{ConsTag} \cdot \tau \cdots \konst{ConsTag} \cdot \tau \cdot \konst{NilTag}
\]

\item [$\blacktriangleright$] Semantics: $s \in \LangTheta{\konst{List}\;\tau} \iff
  s \in (\konst{ConsTag} \cdot \LangTheta{\tau})^{*} \cdot \konst{NilTag}$.

\item [$\blacktriangleright$] More complex structures are built on
  lists. For example, arithmetic expressions, logic formulas, program
  syntax trees.*


\end{itemize}
\end{frame}


\begin{frame}[fragile]\frametitle{Bit-level messages}

In CASE Phase 3, we deal with \kemph{ADS-B} messages, which are
specified in terms of bits.

{\small
\begin{verbatim}
heartbeat =
   {messageID : u8
    status_byte_1 :
       {GPS-Pos-Valid : u1
        Maint-Reqd    : u1
        IDENT         : u1
        Addr-Type     : u1
        GPS-Batt-Low  : u1
        RATCS         : u1
        reserved      : u1
        UAT-Initialized : u1
       }
\end{verbatim}
}

\end{frame}

\begin{frame}[fragile]\frametitle{Bit-level messages (contd)}

{\small
\begin{verbatim}
    status_byte_2 :
       {Time-Stamp-MS-bit : u1
        CSA-Requested     : u1
        CSA-Not-Avail     : u1
        reserved          : Raw(4)
        UTC-OK            : u1
       }
    Time-Stamp : u16
    Message-Counts :
     {uplinks : u5, ignore : u1, basic_and_long : u10}
    }
\end{verbatim}}

All field widths are in bits; note the odd sizes like
\kemph{\konst{u5}} and \kemph{\konst{u10}}.

\end{frame}

\begin{frame} \frametitle{Cramming information in can be amusing}

  The timestamp in a \konst{Heartbeat} message is intended to
  represent the number of seconds since UTC midnight.  So in general
\[ 24 * 60 * 60 = 86,400\]
seconds are needed.

Thus, in addition to the 16 bit \konst{Time-Stamp} field (65,536), one
more bit is needed, and it is tucked away in
\konst{Time-Stamp-MS-bit}. Not even contiguous!

\end{frame}

\begin{frame}\frametitle{Implementation}

  To support bit-level specifications required a minimal change,
  requiring the $\highlight{\mathit{lval} \mapsto
    (\mathit{position},\mathit{offset})}$ information held in the
  context map to be understood in terms of bits.

  The rest of the contiguity type machinery was unchanged.

\end{frame}

\section{Monitors and Code Generation}

\begin{frame}\frametitle{CASE Phase 3 Monitors}

\begin{itemize}
\item [$\blacktriangleright$]
  An aircraft receives periodic updates from its ADSB receiver on the
aircraft in its vicinity, in the form of a collection of \kemph{traffic reports}.

\item [$\blacktriangleright$]
  The receiver is deemed to be \kemph{reliable}, so that there is no
need for (say) filtering of its messages.

\item [$\blacktriangleright$]
  Rather, we considered possible attack scenarios achievable using
well-formed messages. A successful attack would cause confusion and
possibly lead to altered flight plans or abandonment of mission.
\end{itemize}

\end{frame}

\begin{frame}\frametitle{CASE Phase 3 Monitors (contd)}

\begin{enumerate}
\item \kemph{Duplicates}. Multiple aircraft with the same ID.

\item \kemph{Impossible motion}. An aircraft that is moving in a
  physically impossible manner (moving too fast, turning too tightly,
  \etc.)

\item \kemph{Sudden Appearance}. Aircraft that ``suddenly pop up'' so
  close that they should have been detected earlier.

\end{enumerate}

The first is stateless.

The latter two are \kemph{differential} (temporal) in nature: previous
traffic reports need to be kept in order to compare against the present one.

\end{frame}

\begin{frame}\frametitle{`Sudden Appearance' Monitor Snippet}

\hspace*{10mm}\includegraphics[width=90mm,height=40mm]{monitor.png}

\begin{itemize}
\item [$\blacktriangleright$] Spec language is essentially Lustre
\item [$\blacktriangleright$] Assume-Guarantee contracts on components can be stated
\item [$\blacktriangleright$] Checked via SMT-based model checker
\end{itemize}

\end{frame}

\begin{frame}\frametitle{Code Generation}

\begin{itemize}
\item [$\blacktriangleright$] We synthesize monitors from a combination of architectural and
logical specifications.
\item [$\blacktriangleright$] Details are in a paper submitted to
  MODELS 2021, in which we also sketch out the correctness argument

\end{itemize}

\vspace*{5mm}

\kemph{Some measurements}

\vspace*{3mm}

For CASE phase 3, 70\% to 93\% of code size
for the monitors is devoted to encoding and decoding messages, plus
doing IO.

\vspace*{4mm}

The formal language based infrastructure for CASE security components
is the \kemph{bulk} of the software. And it is being synthesized.

\end{frame}


\section{Future Directions}

\begin{frame} \frametitle{Formal Languages and Security}

There are two important roles for formal languages in security,
corresponding roughly to \kemph{offense} and \kemph{defense}.

\begin{description}
\item [Offense] \textit{Expressive DDLs are attackable by virtue of
  their expressiveness}
  \begin{itemize}
    \item [$\blacktriangleright$] Show me your DDL and I will give you an attack on it.
  \end{itemize}
\item [Defense] \textit{Formal DDLs can have natural and direct
  semantics, supporting correct and robust implementations.}
  \begin{itemize}
  \item [$\blacktriangleright$] Take my DDL and build a secure system out of it.
  \end{itemize}
  \end{description}
\end{frame}

\begin{frame} \frametitle{Interesting Next Steps}

\begin{itemize}
\item [$\blacktriangleright$] Wide spectrum application of formal language specs. It
  would be interesting to find an example system built on both
  low-level binary message formats as in CASE, and also complex
  high-level data, as in SafeDocs.

\item [$\blacktriangleright$] Problem to be surmounted/finessed is
  that CASE is aimed at embedded real-time systems, while SafeDocs may
  not have such considerations.

\item [$\blacktriangleright$] Can we express architectural models as
  ``boxes-and-arrows'' where the arrows are specified with formal
  languages and boxes have some simplistic formal specs that can be
  refined? If the bulk of such systems is indeed synthesizable, that
  could be a fruitful approach.

\end{itemize}

\end{frame}


\begin{frame} \frametitle{Interesting Next Steps (contd)}

\begin{itemize}
\item [$\blacktriangleright$] Does this tie in with \kemph{Zero-Trust} architectures?

\item [$\blacktriangleright$]
  Does synthesis from specs provide a helpful mitigation to supply chain attacks?

\end{itemize}

\end{frame}

\begin{frame}\frametitle{The End}\end{frame}


\begin{frame} \frametitle{Compilation}

\begin{itemize}

\item [$\blacktriangleright$] The contig. type parser generator
  operates in an essentially \kemph{interpreted} mode.

\item [$\blacktriangleright$] Our generated filters in CASE can keep
  up with the rest of the system, but we would like to have filters
  and monitors that run at max. speed.

\item [$\blacktriangleright$] We know how to \kemph{compile}
  contig. types and would like to implement this translator, prove
  it correct, and apply to challenging examples.

\end{itemize}

\end{frame}


\begin{frame}[fragile]\frametitle{Challenge: first order terms}

Can be described by the following datatype:

{\small
\begin{verbatim}
  term = Var of string
       | App of string * term list
\end{verbatim}}

A contiguity type for this could look something like
%
{\small
\begin{verbatim}
  term = {
    tag : u8
    kind : Union {
           tag = VarTag ==> {varName : string}
           tag = AppTag ==> {fnName : string, Args : List term}}
   }
\end{verbatim}}

It would be interesing and useful to create a `compiler' from the
above kinds of (recursive) datatype definitions to the corresponding
contiguity type.

\end{frame}

\begin{frame}\frametitle{Connection with functional programming}

\begin{itemize}

\item [$\blacktriangleright$] Modelling of recursive datatypes in
  contiguity types seems like a representation-level version of
  \kemph{iso-recursive} types.

\item [$\blacktriangleright$] Could also pursue inclusion of user-defined
  computations in the matcher as it computes.

\item [$\blacktriangleright$] The matcher can be viewed as a kind of
  \konst{fold} from the left, where one of the components of the
  ``accumulator'' is the matcher context. This gives space for the
  user to add in their own data to be computed and accumulated as the
  matcher progresses.


\end{itemize}

\end{frame}

\begin{frame}\frametitle{Combination with conventional parser technology}

What we seem to have is a type-directed and context-oriented parser
generator that has some similarities with LL(0) or LR(0) languages
wherein the parser can proceed with no lookahead.

\begin{itemize}

\item  [$\blacktriangleright$] This is useful for binary-encoded datastructures.

\item [$\blacktriangleright$] Can it be generalized to use lookahead
  to handle more complex, text-based representations of data such as
  JSON?

\item [$\blacktriangleright$] Something like Greibach normal form (all
  grammar rules start with a terminal on rhs) might give a place to
  start. Lots of work to do yet here.

\item [$\blacktriangleright$]
\kemph{Idea (Hardin)} Can we `lift' so that contiguity types are
  used to specify the lexeme level, and use (say) an LR parser
  generator to handle higher-level grammar elements?
\end{itemize}

\end{frame}

\begin{frame} \frametitle{Modular parsing}

SafeDocs has shown that difficult languages such as PDF can involve
multiple sub-languages, which may need coordination in their
parsing.

\begin{itemize}

\item [$\blacktriangleright$] What seems to be needed is a way to---in
  the midst of parsing language $A$---select a subsequence of the
  input to separately parse with the parser for language $B$.

\item [$\blacktriangleright$] In
  determining the slice of the input to give to $B$, the accumulated
  context often needs to be consulted.

\item [$\blacktriangleright$] Contiguity types give a way to handle
  this, and, in particular, may also offer a framework in which the
  context accumulated by $B$ is added back to that of $A$.

\end{itemize}

\end{frame}


\begin{frame}\frametitle{Interesting Directions}

\begin{itemize}

\item [$\blacktriangleright$] System modelling as `boxes and arrows'
  where the arrows are specified by contiguity types. Thus would get
  an interesting overview of the message formats in the system, early
  on in design. Are there interesting security analyses that can be
  done at that point? Probably we will need to add some behavior to
  the boxes. (Currently doing just this in CASE.)


\item [$\blacktriangleright$] Auto-generation of test suites and harnesses from contig. type specs.

\item [$\blacktriangleright$] New and challenging examples

\item [$\blacktriangleright$] Others?

\end{itemize}

\end{frame}


\end{document}

%% \begin{frame} \frametitle{Relationship with standard parsing technology}

%%   \begin{itemize}

%% \item [$\blacktriangleright$] Proved parser generator sound (every
%%   successfully parsed message is in the language of the given
%%   contiguity type).

%% \item [$\blacktriangleright$] We are integrating a pre-existing
%%   max. munch lexer generator. (Formal correctness proof from previous
%%   work with Scott Owens).

%% \item [$\blacktriangleright$] We have existing SLR and PEG parsers
%%   that are formally verified, and want to integrate with them.

%% \end{itemize}

%% \end{frame}
