Code gen for UXAS filter and monitor components is done over a CakeML
code base comprising the following structures:

  - Utils : utility functions, including basic maps from strings to
      ints and doubles.

  - Contig : implementation of contig type framework, including
      matching and parsing engines.

  - CMASI : CakeML implementations of types declared in
      CMASI.aadl. Also, record projections for all records
      types. Mainly auto-generated, with a few minor post-facto
      tweaks.

  - CM_Property_Set : constants for a variety of things. For us, the
      important ones have names ending in "_Bit_Codec_Max_Size".

  - CMASI_Contig : contig types for the message types used in our
      examples. These power both filters and parsers.

  - CMASI_Mesg : Hand-written functions mapping from parse trees
      (Contig.ptree) to the relevant CMASI types.

The rough idea is that an input port for a filter or monitor has an
attached contiguity type that gives the expected format of messages
arriving on the port. For a filter enforcing a well-formedness
property P, it is expected that in-message assertions enforce P. In
that case, running the matcher on the input suffices to determine a
verdict. We use this in all our filter examples.

For monitors, the assumption is that each input port will be parsed
into a data type declared in CMASI and operated on by expressions
based on funs declared in various places, including the monitor
definition.


Buffers.
---------

Splat-generated code for filters and monitors interacts with
HAMR-generated code. A key fact is that splat generates CakeML code,
which is not "callable" from outside. Thus HAMR-generated code for
such a component can't "call" the component behavior when its inputs
are available. Instead, the CakeML component (call it "Comp")
interacts with HAMR-generated code in the following way:

  - HAMR defines a CakeML FFI call for each input and output port of
    Comp

  - A buffer for each input port is declared in Comp.

  - Comp enters a loop that takes the following steps:

      1. Comp notifies HAMR that it is ready for inputs.

      2. When HAMR has obtained the inputs, it responds to Comp.

      3. Comp invokes the CakeML FFI functions generated by HAMR to
         fill its input buffers.

      4. Comp executes on its input buffers.

      5. Comp uses FFI calls to write the outputs.

      6. Comp notifies HAMR that it is finished and goes to (1).


Compiling and Running Generated Filters
----------------------------------------

A filter description for a filter named "Filt" results in a CakeML
file "Filt.cml" being generated. It's quite readable should one want
to modify the generated code. To compile it you need also need

    cake.S
    basis_ffi.c
    Makefile

to be in the compilation directory. The desired CakeML executable is built with

  make Filt.cake

or, if all .cml files in the directory are to be compiled, simply invoke

  make

The resulting executables, by default, support input from a file
holding an input message, and output the result to std_out (if the
message passes). For example, we have some example messages in
codegen/traces.

  $ ls ../traces
  ARQTE  ARSPE  AVSE  LSTE  ORE

and one can execute the OperatingRegion filter as follows:

  $ ./CASE_Filter_OR_thr.cake ../traces/ORE
  Taking input from file : ../traces/ORE.
  afrl.cmasi.OperatingRegion$lmcp|afrl.cmasi.OperatingRegion|TcpBridge|400|68$LMCP ....

Failure messages are also emitted for bad inputs. The important thing
is that the message is not passed on to std_out.:

  $ ./CASE_Filter_OR_thr.cake ../traces/LSTE
  Taking input from file : ../traces/LSTE.
  Filter rejects message: writing input to buffer failed. string2buf: string too large for buffer


Building with HAMR
-------------------

The above examples show a "mocked-up" IO interface in use. However,
CASE components are built with HAMR, and communication is then done
through the CakeML FFI. We generate code for this too, except it is commented out.
In particular, in Filt.cml:

  - the commented-out "API" and "Control" structures should be
    uncommented, and

  - the original uncommented API structure should be commented out, or
    deleted.
